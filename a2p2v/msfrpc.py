#!/usr/bin/env python3
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Perspecta Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

""" Metasploit RPC module
"""
import json
import logging
from typing import Dict, List, Set, Union

import msgpack
import requests

from .common import create_default_metasploit_config
from .config import config

logger = logging.getLogger(__name__)

DEFAULT_OPTIONS = {
    "exploit/multi/elasticsearch/script_mvel_rce": {
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/",
    },
    "exploit/multi/http/axis2_deployer": {
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
    },
    "exploit/multi/http/struts_dmi_rest_exec": {
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/",
    },
    "exploit/multi/http/tomcat_mgr_upload": {
        "RHOST": "$target_host",
        "RPORT": 8282,
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/",
    },
    "exploit/multi/http/wp_ninja_forms_unauthenticated_file_upload": {
        "RHOST": "$target_host",
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/wordpress/",
        "FORM_PATH": "/index.php/king-of-hearts/",
    },
    "exploit/multi/misc/java_jmx_server": {},
    "exploit/multi/misc/weblogic_deserialize_asyncresponseservice": {
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/",
    },
    "exploit/windows/iis/iis_webdav_scstoragepathfromurl": {
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/",
    },
    "exploit/windows/rdp/cve_2019_0708_bluekeep_rce": {},
    "exploit/windows/smb/ms17_010_psexec": {},
    "exploit/windows/smb/ms17_010_eternalblue": {},
    "exploit/windows/smb/ms10_061_spoolss": {},
}

ALLOWED_MODULES = [
    "exploit/multi/elasticsearch/script_mvel_rce",
    "exploit/multi/http/axis2_deployer",
    "exploit/multi/http/struts_dmi_rest_exec",
    "exploit/multi/http/tomcat_mgr_upload",
    "exploit/multi/http/wp_ninja_forms_unauthenticated_file_upload",
    "exploit/multi/misc/java_jmx_server",
    "exploit/multi/misc/weblogic_deserialize_asyncresponseservice",
    "exploit/unix/ftp/vsftpd_234_backdoor",
    "exploit/unix/irc/unreal_ircd_3281_backdoor",
    "exploit/unix/misc/distcc_exec",
    "exploit/windows/iis/iis_webdav_scstoragepathfromurl",
    "exploit/windows/rdp/cve_2019_0708_bluekeep_rce",
    "exploit/windows/smb/ms17_010_eternalblue",
    "exploit/windows/smb/ms17_010_psexec",
    "exploit/windows/smb/ms10_061_spoolss",
]

ALLOWED_FIELDS = set(['type', 'name', 'fullname', 'rank', 'description'])

ALLOWED_OPTIONS = set(
    [
        "RHOST",
        "RHOSTS",
        "LPORT",
        "TARGETURI",
        "FORM_PATH",
        "RPORT",
        "HttpUsername",
        "HttpPassword",
    ]
)


# Variables
class MsfRpcClient:
    """This class is used to interact with the Metasploit RPC API.
    To use it, the Metasploit RPC daemon must be first running.
    It can be started using the command msfrpcd command.
    e.g. msfrpcd -P welcome1 -S -U msf -a 127.0.0.1 -f -p 55552
    """

    def __init__(self):
        """Obtain the MSF API parameters from the configuration."""
        # Parameters are stored in config
        host = config.get('METASPLOIT', 'host', fallback='127.0.0.1')
        port = config.get('METASPLOIT', 'port', fallback=55552)
        uri = config.get('METASPLOIT', 'uri', fallback="/api/")

        self.username = config.get('METASPLOIT', 'user', fallback='msf')
        self.password = config.get(
            'METASPLOIT', 'password', fallback='welcome1'
        )
        self.ssl = config.get('METASPLOIT', 'ssl', fallback=False)
        self.token = False
        self.headers = {"Content-type": "binary/message-pack"}
        if self.ssl:
            self.url = f"https://{host}:{port}{uri}"
        else:
            self.url = f"http://{host}:{port}{uri}"

    def login(self):
        """Login to the MSF API and store the token"""
        if not self.token:
            logger.info("Logging in to MSF API at %s", self.url)
            result = requests.post(
                self.url,
                data=msgpack.packb(
                    ["auth.login", self.username, self.password]
                ),
                headers=self.headers,
                verify=False,
            )
            response = msgpack.unpackb(result.content)
            self.token = response.get(b"token", "").decode("utf-8")
            logger.debug("Response: %s", response)

    def logout(self):
        """Logout of the MSF API and invalidate the token"""
        if self.token:
            logger.info("Logging out of MSI API")
            result = requests.post(
                self.url,
                data=msgpack.packb(["auth.logout", self.token]),
                headers=self.headers,
                verify=False,
            )
            self.token = False
            logger.info("Logged out: %s", result)

    def search(self, module_filter: str = "") -> List[Dict[str, str]]:
        """Use the module.search API command to look for modules
        Arguments:
            module_filter(str): filter to pass to module.search
        Returns:
            modules: list of modules with type, name, fullname, rank and
                     disclosuredate
        """
        logger.info('Calling module.search %s', module_filter)
        result = requests.post(
            self.url,
            data=msgpack.packb(["module.search", self.token, module_filter]),
            headers=self.headers,
            verify=False,
        )
        modules = msgpack.unpackb(result.content)
        return modules

    def info(self, fullname: str) -> Dict:
        """Use the module.info API command to get module details
        Arguments:
            fullname(str): module name
        Returns:
            dict: details about the module including options
        """
        logger.debug("Calling module.info: fullname = %s", fullname)
        result = requests.post(
            self.url,
            data=msgpack.packb(["module.info", self.token, "", fullname]),
            headers=self.headers,
            verify=False,
        )
        try:
            info = msgpack.unpackb(
                result.content, strict_map_key=False, raw=False
            )
        except ValueError as error:
            info = result.content
            logger.error(error)

        return info

    @classmethod
    def decode(cls, value: Union[str, bytes]) -> str:
        """Decode a byte string, if provided
        Arguments:
            value (str or bytes): input value
        Returns:
            str: value decoded as a string
        """
        if isinstance(value, bytes):
            value = value.decode("utf-8")
        return value

    @classmethod
    def decode_dict(cls, dictionary: Dict) -> Dict:
        """Decode the items in a dictionary
        Arguments:
            dictionary (dict): a dictionary
        Returns:
            dict: dictionary with values decoded
        """
        result = {
            cls.decode(name): cls.decode(value)
            for name, value in dictionary.items()
        }
        return result

    def _parse_cves(self, references: List[List]) -> List[str]:
        """Given the references in the Metasploit module information,
           parse out a list of CVE numbers:
        Arguments:
            list: list of references from MSF module info
        Returns:
            list: cve numbers
        """
        cve_list = []
        for reference in references:
            try:
                reference_type, reference_id = reference
                reference_type = self.decode(reference_type)
                reference_id = self.decode(reference_id)

                if reference_type == 'CVE':
                    cve_list.append(reference_id)
            except AttributeError as error:
                logger.error(error)
            except ValueError as error:
                logger.error(error)

        return cve_list

    def parse_info(self, fullname: str) -> Dict:
        """Retrieve module information, parse it and return a simplified dataset:
           - Limit items to fields in ALLOWED_FIELDS
           - Place CVE references in a new list indexed by "cves"
           - Format options into a list of name, value pairs where
             - name is the option
             - value is the default value

        Arguments:
            fullname (str): module name
        Returns:
            dict: parsed information
        """
        json_result = {}
        info = self.info(fullname)

        # Get top level fields
        for name, value in info.items():
            name = self.decode(name)
            if name in ALLOWED_FIELDS and isinstance(value, bytes):
                value = value.decode("utf-8")
                json_result[name] = value

        # Architectures
        arch_list = []
        for arch in info.get(b'arch', []):
            arch = self.decode(arch)
            arch_list.append(arch)

        json_result['arch'] = arch_list

        # Targets
        targets = self.decode_dict(info.get(b'targets', {}))
        json_result['targets'] = targets

        # Only obtain CVEs from the references
        json_result['cves'] = self._parse_cves(info.get(b'references', []))

        # Only get the options we are interested in
        options = {}
        default_options = DEFAULT_OPTIONS.get(fullname, {})

        for option_name, option_values in info.get(b"options", {}).items():
            option_name = self.decode(option_name)

            if option_name in ALLOWED_OPTIONS:
                option_value = self.decode(option_values.get(b"default", ""))
                option_value = default_options.get(option_name, option_value)
                options[option_name] = option_value

        json_result["options"] = options

        return json_result

    @classmethod
    def get_broken_modules(cls) -> Set[str]:
        """Get names of broken modules and avoid querying them."""
        broken_modules = set()
        broken = (
            config.get('METASPLOIT', 'broken_modules', fallback='None')
            .replace('"', '')
            .replace("'", "")
        )

        for broken_module in broken.split(' '):
            logger.info('Broken module %s', broken_module)
            broken_modules.add(broken_module)

        return broken_modules

    def get_all_modules(self) -> List[str]:
        """Get a list of all module names, skipping broken modules
        Returns:
            list: metasploit module names (fullname)
        """
        module_names = []
        broken_modules = self.get_broken_modules()
        logger.info('Querying module information')
        modules = self.search("")

        for module in modules:
            module_name = self.decode(module.get(b"fullname", ""))
            if module_name in broken_modules:
                logger.info('Skipping broken module %s', module_name)
            else:
                module_names.append(module_name)

        return module_names

    def create_metasploit_config(
        self, details_db_filename: str, only_allowed_modules: bool = True
    ):
        """Create the metasploit configuration file by querying MSF RPC API.
           If there are any issues connecting to the API, use the default.

        Arguments:
            details_db_filename(str): name of the output file
            only_allowed_modules(bool): if True, limit to a subset of modules
        """
        try:
            self._create_metasploit_config_from_api(
                details_db_filename, only_allowed_modules
            )
        except requests.exceptions.ConnectionError as error:
            logger.error(error)
            logger.error(
                'Could not connect to Metasploit API - '
                'Using default Metasploit configuration'
            )
            print(
                "Could not connect to Metasploit API - "
                "Using default Metasploit configuration."
            )
            create_default_metasploit_config()

    def _create_metasploit_config_from_api(
        self, details_db_filename: str, only_allowed_modules: bool = True
    ):
        """Create the metasploit configuration file by querying MSF RPC API.
           Get list of module names, query and parse module information,
           store the results to a JSON formatted file.

        Arguments:
            details_db_filename(str): name of the output file
            only_allowed_modules(bool): if True, limit to a subset of modules
        """
        output = {}
        self.login()

        # Get the appropriate set of module names
        if only_allowed_modules:
            logger.info(
                'Loading only allowed modules.  To load all, run with --reload'
            )
            module_names = ALLOWED_MODULES
        else:
            logger.info(
                'Loading ALL Metasploit modules, may take a few minutes'
            )
            module_names = self.get_all_modules()

        # Parse the information from all the modules
        for module_name in module_names:
            info = self.parse_info(module_name)
            output[module_name] = info

        # Write to file
        with open(details_db_filename, 'w') as out_fp:
            json.dump(obj=output, fp=out_fp, indent=4)
        self.logout()


def main():
    """Create a metasploit configuration file in the current directory."""
    logger.setLevel('DEBUG')
    stream_handler = logging.StreamHandler()
    stream_handler.setLevel('DEBUG')

    # create formatter
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    stream_handler.setFormatter(formatter)
    logger.addHandler(stream_handler)

    rpc = MsfRpcClient()
    rpc.create_metasploit_config('metasploit_config.json')


if __name__ == "__main__":
    main()
