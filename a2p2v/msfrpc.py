#!/usr/bin/env python3
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Perspecta Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


import json
import logging
import requests
import msgpack

from .config import config

logger = logging.getLogger(__name__)

DEFAULT_OPTIONS = {
    "exploit/multi/elasticsearch/script_mvel_rce": {
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/",
    },
    "exploit/multi/http/axis2_deployer": {
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
    },
    "exploit/multi/http/struts_dmi_rest_exec": {
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/",
    },
    "exploit/multi/http/tomcat_mgr_upload": {
        "RHOST": "$target_host",
        "RPORT": 8282,
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/",
    },
    "exploit/multi/http/wp_ninja_forms_unauthenticated_file_upload": {
        "RHOST": "$target_host",
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/wordpress/",
        "FORM_PATH": "/index.php/king-of-hearts/",
    },
    "exploit/multi/misc/java_jmx_server": {},
    "exploit/multi/misc/weblogic_deserialize_asyncresponseservice": {
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/",
    },
    "exploit/windows/iis/iis_webdav_scstoragepathfromurl": {
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/",
    },
    "exploit/windows/rdp/cve_2019_0708_bluekeep_rce": {},
    "exploit/windows/smb/ms17_010_psexec": {},
    "exploit/windows/smb/ms17_010_eternalblue": {},
    "exploit/windows/smb/ms10_061_spoolss": {},
}

ALLOWED_MODULES = [
    "exploit/multi/elasticsearch/script_mvel_rce",
    "exploit/multi/http/axis2_deployer",
    "exploit/multi/http/struts_dmi_rest_exec",
    "exploit/multi/http/tomcat_mgr_upload",
    "exploit/multi/http/wp_ninja_forms_unauthenticated_file_upload",
    "exploit/multi/misc/java_jmx_server",
    "exploit/multi/misc/weblogic_deserialize_asyncresponseservice",
    "exploit/unix/ftp/vsftpd_234_backdoor",
    "exploit/unix/irc/unreal_ircd_3281_backdoor",
    "exploit/unix/misc/distcc_exec",
    "exploit/windows/iis/iis_webdav_scstoragepathfromurl",
    "exploit/windows/rdp/cve_2019_0708_bluekeep_rce",
    "exploit/windows/smb/ms17_010_eternalblue",
    "exploit/windows/smb/ms17_010_psexec",
    "exploit/windows/smb/ms10_061_spoolss",
]

ALLOWED_FIELDS = set(['type', 'name', 'fullname', 'rank', 'description'])

ALLOWED_OPTIONS = set(
    [
        "RHOST",
        "RHOSTS",
        "LPORT",
        "TARGETURI",
        "FORM_PATH",
        "RPORT",
        "HttpUsername",
        "HttpPassword",
    ]
)

# Variables
class MsfRpcClient:
    def __init__(self):
        # Parameters are stored in config
        self.host = config.get('METASPLOIT', 'host', fallback='127.0.0.1')
        self.port = config.get('METASPLOIT', 'port', fallback=55552)
        self.username = config.get('METASPLOIT', 'user', fallback='msf')
        self.password = config.get('METASPLOIT', 'password', fallback='welcome1')
        self.uri = config.get('METASPLOIT', 'uri', fallback="/api/")
        self.ssl = config.get('METASPLOIT', 'ssl', fallback=False)
        self.token = False
        self.headers = {"Content-type": "binary/message-pack"}
        if self.ssl:
            self.url = f"https://{self.host}:{self.port}{self.uri}"
        else:
            self.url = f"http://{self.host}:{self.port}{self.uri}"

    def login(self):
        if not self.token:
            logger.info(f"Logging in to MSF API at {self.url}")
            result = requests.post(
                self.url,
                data=msgpack.packb(
                    ["auth.login", self.username, self.password]
                ),
                headers=self.headers,
                verify=False,
            )
            response = msgpack.unpackb(result.content)
            self.token = response.get(b"token", "").decode("utf-8")

    def logout(self):
        if self.token:
            logger.info("Logging out of MSI API")
            result = requests.post(
                self.url,
                data=msgpack.packb(["auth.logout", self.token]),
                headers=self.headers,
                verify=False,
            )
            self.token = False

    def search(self, module_filter=""):
        logger.info('Calling module.search %s', module_filter)
        result = requests.post(
            self.url,
            data=msgpack.packb(["module.search", self.token, module_filter]),
            headers=self.headers,
            verify=False,
        )
        modules = msgpack.unpackb(result.content)
        return modules

    def info(self, fullname):
        logger.debug(f"Calling module.info: fullname = %s", fullname)
        result = requests.post(
            self.url,
            data=msgpack.packb(["module.info", self.token, "", fullname]),
            headers=self.headers,
            verify=False,
        )
        try:
            info = msgpack.unpackb(
                result.content, strict_map_key=False, raw=False
            )
        except ValueError as e:
            info = result.content
            logger.error(e)

        return info

    def decode(self, value):
        if isinstance(value, bytes):
            value = value.decode("utf-8")
        return value

    def decode_dict(self, d):
        result = { self.decode(name):self.decode(value) for name, value in d.items() }
        return result

    def parse_info(self, fullname):
        json_result = {}
        info = self.info(fullname)

        # Get top level fields
        for name, value in info.items():
            name = self.decode(name)
            if name in ALLOWED_FIELDS and isinstance(value, bytes):
                value = value.decode("utf-8")
                json_result[name] = value

        # Architectures
        arch_list = []
        for arch in info.get(b'arch', []):
            arch = self.decode(arch)
            arch_list.append(arch)

        json_result['arch'] = arch_list

        # Targets
        targets = self.decode_dict(info.get(b'targets', {}))
        json_result['targets'] = targets

        # Only obtain CVEs from the references
        cve_list = []
        for reference in info.get(b'references', []):
            try:
                reference_type, reference_id = reference
                reference_type = self.decode(reference_type)
                reference_id = self.decode(reference_id)

                if reference_type == 'CVE':
                    cve_list.append(reference_id)
            except Exception as e:
                pass

        json_result['cves'] = cve_list

        # Only get the options we are interested in
        options = {}
        default_options = DEFAULT_OPTIONS.get(fullname, {})

        for option_name, option_values in info.get(b"options", {}).items():
            option_name = self.decode(option_name)

            if option_name in ALLOWED_OPTIONS:
                option_value = self.decode(option_values.get(b"default", ""))
                option_value = default_options.get(option_name, option_value)
                options[option_name] = option_value

        json_result["options"] = options

        return json_result


    def get_broken_modules(self):
        broken_modules = set()
        broken = config.get('METASPLOIT', 'broken_modules', fallback='None').replace('"', '').replace("'", "")

        for broken_module in broken.split(' '):
            logger.info('Broken module %s', broken_module)
            broken_modules.add(broken_module)

        return broken_modules

    def get_all_modules(self):
        module_names = []
        broken_modules = self.get_broken_modules()
        logger.info('Querying module information')
        modules = self.search("")

        for module in modules:
            module_name = self.decode(module.get(b"fullname", ""))
            if module_name in broken_modules:
                logger.info('Skipping broken module %s', module_name)
            else:
                module_names.append(module_name)

        return module_names

    def create_metasploit_config(self, details_db_filename: str, only_allowed_modules=True):
        output = {}
        self.login()

        # Get the appropriate set of module names
        if only_allowed_modules:
            logger.info('Loading only allowed modules.  To load all, run with --reload')
            module_names = ALLOWED_MODULES
        else:
            logger.info('Loading ALL Metasploit modules, may take a few minutes')
            module_names = self.get_all_modules()

        # Parse the information from all the modules
        for module_name in module_names:
            info = self.parse_info(module_name)
            output[module_name] = info

        # Write to file
        with open(details_db_filename, 'w') as f:
            json.dump(obj=output, fp=f, indent=4)
        self.logout()
        

def example1():
    rpc = MsfRpcClient()
    rpc.login()
    modules = rpc.search("eternalblue")
    for module in modules:
        fullname = module.get(b"fullname", "").decode("utf-8")
        info = rpc.info(fullname)
        print(module)
        print(info)
        print("-" * 50)


def main():
    logger.setLevel('DEBUG')
    ch = logging.StreamHandler()
    ch.setLevel('DEBUG')

    # create formatter
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    rpc = MsfRpcClient()
    rpc.create_metasploit_config('metasploit_config.json')


if __name__ == "__main__":
    main()
