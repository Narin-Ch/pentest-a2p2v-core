#!/usr/bin/env python3.7
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Perspecta Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


import argparse
import collections
import datetime
import json
import logging
import os
import re
import string
import subprocess
import time
import matplotlib.pyplot as plt
import matplotlib as mpl
import networkx as nx

from .visualizer import Visualizer
from .config import config
from .executor import Simulator
from .metasploitdb import MetasploitDB

logger = logging.getLogger(__name__)

class Report(object):
    def __init__(self, filename='report_{}.txt'):
        self.filename = filename
        self._out = None

    def __enter__(self):
        self._out = open(self.filename, 'w')

    def __exit__(self, exc_type, exc_value, exc_traceback):
        close(self._out)

    def write_full_report(self):
        self._write_header()

    def _writeln(self, s=''):
        if (self._out != None):
            self._out.write('{}\n'.format(s))

    def _write_header(self):
        pass
    

class Organizer(object):
    def __init__(self, planner, mode, minimum_score, visualizations=False, execute=False, post_execute_script=None, lhost=None, gui=False):
        '''Create a new organizer given an attack tree
        Arguments:
            attack_trees(list): list of attack trees
        '''
        # Create deposits for results
        self._targets = set()
        self._score = None
        self._goals = None
        self._details = {}
        self._evidence = []

        self._gui = gui
        self._lhost = lhost
        self.attack_trees = planner.attack_trees
        self.execute_enabled = execute
        self._last_password = None                  # Keep track of last password used for sudo
        self._current_session = None                # Keep track of last opened session ID
        self._exec_mode = mode                      # Execution mode ('single' for single host, 'system' for system, 'black' for blackbox)
        self._scan_ports = "1-1024"
        self._min_score = minimum_score
        self._visualizations = visualizations
        if self._visualizations:
            self._visualizer = Visualizer()

        self.exec_graph = nx.Graph()
        self.exec_graph.add_node('ATTACKER')
        self.previous_node = 'ATTACKER'
        self.edge_labels = {}
        self.o_nodes = {"nodes": ['ATTACKER'], "sizes": [500], "colors": ['#33cc33']}
        self.v_nodes = {"nodes": [], "sizes": [], "colors": []}

        # If we are in system mode and visualizations are enabled and the 'loadtrees' option wasn't utilized
        # enabled network graph and composite attack tree visualizations
        if self._exec_mode == 'system' and self._visualizations and not self._gui and hasattr(planner, 'hostsDB'):
            logger.info("Displaying internal network representation")
            self._visualizer.show_network_vis(planner.hostsDB, planner.networkGraph)
            logger.info("Displaying combined attack tree representation")
            self._visualizer.show_attack_trees_vis(planner)

        self.execute_enabled = False
        self._executor = Simulator()

        if self.execute_enabled:
            logger.debug("*** Organizer Currently Configured to Perform LIVE execution ***")
        else:
            logger.debug("*** Organizer Currently Configured to Perform SIMULATED execution ***")

        # This allows you to reference by: self._issues[host][issue]
        self._issues = collections.defaultdict(lambda : collections.defaultdict(collections.defaultdict))

        # Regex patterns for matching responses from Metasploit API
        self.is_done_pattern = re.compile(r'Command shell session|Meterpreter session|Exploit completed|execution completed|Route added')
        self.success_pattern = re.compile(r'Meterpreter session \d+ opened|Command shell session \d+ opened|success|Success|succeeded|Succeeded|Found shell|Route added')
        self.failure_pattern = re.compile(r'RuntimeError|Invalid session identifier|Meterpreter session \d+ closed|Post failed|no session was created')
        self.session_success_pattern = re.compile(r'Meterpreter session \d+ opened|Command shell session \d+ opened')
        self.command_shell_success_pattern = re.compile(r'Command shell session \d+ opened')
        self.meterpreter_shell_success_pattern = re.compile(r'Meterpreter shell session \d+ opened')

        self._post_execute_script = post_execute_script

    def sleep(self, num_seconds=0):
        if self.execute_enabled:
            time.sleep(num_seconds)

    def init_executor(self):
        if self._executor.valid != True:
            return False
        self.skip_banner()
        self.set_metasploit_globals()
        return True

    def skip_banner(self, max_tries=1000):
        tries = 0
        while not 'prompt' in self._executor.read() and tries < max_tries:
            tries += 1

    def set_metasploit_globals(self):
        self._log_line('```\n\n')
        #payload = config.get('METASPLOIT', 'payload', fallback='windows/meterpreter/bind_tcp')
        #self.send_command(f'set payload {payload}')
        self.send_command('set EXITFUNC process')
        self.send_command('set LHOST {}'.format(self._lhost))
        self._log_line('\n\n```\n\n')

    @classmethod
    def get_timestamp(cls, stampType):
        if stampType == 1:
            FORMAT = '%m/%d/%Y %H:%M'
        else:
            FORMAT = '%m%d%Y%H%M'
        return datetime.datetime.strftime(datetime.datetime.now(), FORMAT)

    def create_report(self, planning):
        if not os.path.exists('reports'):
            os.makedirs('reports')

        filename_timestamp = Organizer.get_timestamp(2)

        report_filename = "reports/report_{}.md".format(filename_timestamp)
        with open(report_filename, 'w') as report:
            report.write('# Report generated on {}\n\n'.format(Organizer.get_timestamp(1)))
    
            # Print summary
            if self.execute_enabled:
                report.write('## Summary of Execution\n\n')
            else:
                report.write('## Summary of Simulated Execution\n\n')
            report.write('---\n\n')

            if planning:
                report.write('    Attack Tree Score: {}\n'.format(self._score))
                report.write('    Goals Reached: {}\n'.format(','.join(self._goals)))
                report.write('---\n\n')
    
            report.write('{:11}|{:20}|{:20}|{:}|\n'.format('Sensitivity', 'Host', 'Success', 'Capability'))
            report.write(':' + '-' * 11 + '|:' + '-' * 20 + ':|:' + '-' * 20 + ':|:' + '-'*100 + '|\n')
    
            for host in sorted(self._issues.keys()):
                for issue, value in self._issues[host].items():
                    success = str(value['success'])
                    if value['sensitive']:
                        report.write("{:11}|".format(value['sensitive']))
                    else:
                        report.write("{:11}|".format('NONE'))
                    report.write('{:20}|{:20}|{}\n'.format(host, success, issue))
            report.write('\n')
            report.write('---\n\n')
    
            # Print details
            if not planning:
                report.write('## The following targets were provided:\n\n')
    
                for target in sorted(self._targets):
                    report.write('- {}\n'.format(target))
                report.write('\n---\n')
        
            report.write('\n')

            report.write('## Details of Utilized Capabilities:\n\n')
            for issueDetail in sorted(self._details.keys()):
                #report.write('-'*140 + '\n')
                report.write('### {}\n\n'.format(issueDetail))
                report.write('- Exploit Class: {}\n'.format(self._details[issueDetail]['expClass']))
                report.write('- Severity: {}\n'.format(self._details[issueDetail]['severity']))
                report.write('- Rank: {}\n'.format(self._details[issueDetail]['rank']))
                cves = self._details[issueDetail]['cves'].split(',')
                if cves[0] != '':
                    report.write("- CVEs\n")
                    for cve in self._details[issueDetail]['cves'].split(','):
                        report.write("\t- [{}](https://nvd.nist.gov/vuln/detail/{})\n".format(cve,cve))
                solution = self._details[issueDetail]['solution']
                if solution:
                    report.write('- Solution: {}\n\n'.format(self._details[issueDetail]['solution']))
                #report.write('-'*140 + '\n')
            report.write('\n\n')
            
            #report.write('The following plugins were enabled:\n\n')
            #report.write('- TODO\n\n')
            report.write('---\n\n')
   
            report.write('## Execution Evidence\n\n')
            report.writelines(self._evidence)

        logger.info("Report written to: {}".format(report_filename))

        return report_filename
        
    def run_post_execution_script(self):
        if not os.path.isfile(self._post_execute_script):
            logger.error('Could not find post execute script: {}'.format(self._post_execute_script))
            return

        logger.info('Running post execute script: {}.'.format(self._post_execute_script))
        subprocess_output = subprocess.check_output(self._post_execute_script)
        logger.info('Sub_process output: {}.'.format(subprocess_output))

    def show_attack_trees(self, trees):
        print('\n')

        if not 'goals' in self.attack_trees[0].keys():
            self._exec_mode = 'single'

        if self._exec_mode == 'single':
            print('{:5}|{:5}|{:}'.format('TREE#', 'SCORE', 'CAPABILITY'))
            print('-' * 5 + '|' + '-' * 5 + '|' + '-' * 50)
        else:
            print('{:5}|{:5}|{:50}|{:50}|{:}'.format('TREE#', 'SCORE', 'HOPS', 'FINAL CAPABILITY OPTIONS', 'GOALS'))
            print('-' * 5 + '|' + '-' * 5 + '|' + '-' * 50 + '|' + '-' * 50 + '|' + '-' * 15)
        trees = sorted(trees, key = lambda i: i['score']['combined'], reverse=True)
        filtered_attack_trees = [attack_tree for attack_tree in trees \
                if not self._min_score or ( self._min_score and attack_tree.get('score', {}).get('combined', 0.0) >= float(self._min_score))]
        final_capability = 'N/A'

        for idx, attack_tree in enumerate(filtered_attack_trees):
            score = attack_tree['score']['combined']
            if not self._min_score or ( self._min_score and score >= float(self._min_score) ):
                hops = []
                for hop in attack_tree['hops']:
                    hopOptions = len(hop['options'])
                    hops.append('{}({})'.format(hop['node'], hopOptions))
                lastHop = attack_tree['hops'][-1]
                printable_idx = idx
                for option in lastHop['options']:
                    final_capability = option['actions'][-1]['value'].split(' ')[0].replace('module=','')
                    if self._exec_mode == 'single':
                        print('{:5}|{:5}|{:}'.format(printable_idx, score, final_capability))
                    else:
                        goals = attack_tree['goals']
                        print('{:5}|{:5}|{:50}|{:50}|{:}'.format(printable_idx, score, '>'.join(hops), final_capability, ' '.join(goals)))
                    printable_idx=score=hops=''
                if idx < len(filtered_attack_trees) - 1:
                    if self._exec_mode == 'single':
                        print('-' * 5 + '|' + '-' * 5 + '|' + '-' * 50)
                    else:
                        print('-' * 5 + '|' + '-' * 5 + '|' + '-' * 50 + '|' + '-' * 50 + '|' + '-' * 15)
        if self._exec_mode == 'single':
            print('-' * 64)
        else:
            print('-' * 129)

    def do_hop(self, hop, node):
        was_successful = False
        severity = hop['severity']
        solution = hop['solution']
        capability_name = hop['capability']
        rank = hop['rank']
        if 'cves' in hop.keys():
            cves = hop['cves']
        else:
            cves = ''
        if 'sensitivity' in hop.keys():
            sensitivity = hop['sensitivity']['type'].upper()
        else:
            sensitivity = {}

        action_list = hop['actions']

        for action_num, action in enumerate(action_list):
            action_type = action['type']
            action_value = action['value']
            action_key = action['key']

            if action_type == 'manual':
                full_name = "Manual action: {}".format(action_value)
                module = action_value
                was_successful = True
                expClass = None
            elif action_type == 'shell_command':
                full_name = "Shell Command: {}".format(action_key)
                module = action_value
                if '$username' in action_value or '$password' in action_value:
                    was_successful = False
                else:
                    was_successful = True
                expClass = None

            elif action_type == 'metasploit':
                # Parse the metasploit module name and values from the string
                results = self.parse_values(action_value)
                logger.debug('results = {}'.format(results))
                if action_key == 'parameters':
                    expClass = "Metasploit (Auxiliary Module)"
                else:
                    expClass = "Metasploit ({})".format(action_key.replace('_',' ').capitalize())

                if 'CMD' in results.keys():
                    full_name = "Metasploit Post Exploitation Module"
                    record_detail = False
                else:
                    record_detail = True
                    # Get the metasploit module name
                    module = results['MODULE']
                    full_name = "Metasploit: {}".format(capability_name)

                logger.info("Attempting: {} on node: {}".format(full_name, node))
                # Begin the evidence section of the report
                self._evidence.append('\n### {}\n'.format(node))
                self._evidence.append('### {}\n\n'.format(full_name))
                short_name = ' '.join(full_name.split(' ')[:3]).split('/')[0]
                if self._visualizations and not self._exec_mode == 'single':
                    self._visualizer.graph_advance(node=node, command=short_name)
                self._evidence.append('\n```\n')

                # Execute the atack step
                was_successful = self.execute(results)
            else:
                logger.error("Unknown action type: {}".format(action_type))
                return

            if record_detail:
                self._issues[node][full_name] = {'success':was_successful, 'sensitive':sensitivity}
                self._details[capability_name] = {'severity':severity, 'cves':cves, 'rank':rank, 'solution':solution, 'expClass':expClass}

            # End the evidence section of the report
            self._evidence.append('\n```\n\n')
            logger.debug('issues[{}][{}] = {}, module = {}'.format(node, full_name, was_successful, module))

            if was_successful:
                logger.info("Successful result on node: {}".format(node))
                if self._visualizations and not self._exec_mode == 'single':
                    self._visualizer.graph_advance(status=10)

            return was_successful

    # TODO: Include ability to perform more complex selection based on criteria
    def selection(self, trees=None, criteria={} ):
        logger.info("Generating list of successful attack trees")
        if not trees:
            trees = self.attack_trees
        # Display the list of attack trees
        self.show_attack_trees(trees)
        # Request the tree from the user
        if self._exec_mode == 'single':
            selected_tree_num = input("Select a capability to execute, 'a' for all, or any other value to skip: ")
            if selected_tree_num == 'a':
                return selected_tree_num
        else:
            selected_tree_num = input('Select an attack tree to execute (or any other value to exit): ')

        if not selected_tree_num.isnumeric() or int(selected_tree_num) > len(trees)-1:
            selected_tree_num = -1
        else:
            selected_tree_num = int(selected_tree_num)

        return selected_tree_num

    def launch(self, treeNum, targets=None):
        if targets is None:
            targets = []

        if len(self.attack_trees) == 0:
            logger.warning("No attack trees produced")
            return False

        if self._exec_mode == 'single':
            for target in targets:
                self._targets.add(target)
                result = self.launch_single_target(target)
        elif self._exec_mode == 'black':
            logger.error("Black box mode is not currently supported")
            return False
        else:
            result = self.launch_system_target(treeNum)

        self._executor.stop_all_sessions()
        self._executor._destroy_console()

        # Launch a post execution script if specified
        if self._post_execute_script:
            self.run_post_execution_script()

        return result

    def launch_system_target(self, treeNum=None):
        logger.debug("Called with: {}".format(treeNum))

        if treeNum == None:
            treeNum = self.selection(criteria={})

        if treeNum >= 0:
            try:
                attack_tree = self.attack_trees[treeNum]
            except:
                logger.error("Attack Tree #{} does not exist".format(treeNum))
                return False
            self._score = attack_tree['score']['combined']
            self._goals = attack_tree['goals']
            hop_list = attack_tree['hops']
            if self._visualizations:
                self._visualizer.initialize_visuals()
            for hop in hop_list:
                hopSuccess = False
                for option in hop['options']:
                    if self.do_hop(option, hop['node']):
                        logger.debug("Hop option Succeeded")
                        hopSuccess = True
                        break
                    else:
                        logger.debug("Hop option Failed")
                if hopSuccess == False:
                    logger.debug("All hop options failed, bailing")
                    break
            if self._visualizations:
                self.sleep(5)
                self._visualizer.cleanup()
            return True
        else:
            return False

    def launch_single_target(self, target):
        logger.info("Launching single host mode execution for target: {}".format(target))
        self._exec_mode = "single"

        target_attack_trees = []
        for attack_tree in self.attack_trees:
            if attack_tree['hops'][0]['node'] == target:
                target_attack_trees.append(attack_tree)

        treeNum = self.selection(trees=target_attack_trees, criteria={})

        if treeNum == 'a':
            attack_trees_to_execute = target_attack_trees
        elif treeNum == -1:
            return True
        else:
            attack_trees_to_execute = [target_attack_trees[treeNum]]

        for attack_tree in attack_trees_to_execute:
            node = attack_tree['hops'][0]['node']
            option = attack_tree['hops'][0]['options'][0]
            self.do_hop(option, node)
            # Cleanup after each step
            self.stop_current_session()

        return True

    def stop_current_session(self):
        '''Use the console to quit the current session if it exists.'''
        if self._current_session:
            logger.debug('Killing session %s', self._current_session)
            self.send_command(f'quit')
            self._current_session = None

    def is_empty(self, results):
        empty = True
        try:
            if results != None and len(results['data']) > 0:
                empty = False
        except Exception as e:
            pass

        return empty

    def is_done(self, results):
        done = False
        try:
            if results != None:
                data = results['data']
                if self.is_done_pattern.search(data):
                    done = True
        except Exception as e:
            pass
        return done

    def is_busy(self, results):
        busy = False
        if results != None:
            try:
                if results['busy'] == True or results['busy'] == 'True' or results['busy'] == 'true':
                    busy = True
            except Exception as e:
                pass
        return busy

    def read_until_not_empty(self, num_attempts=60, delay_time_seconds=1.0):
        attempt_num = 1
        results = {'data':''}

        while attempt_num < num_attempts and len(results['data']) == 0:
            logger.debug('Read Until Not Empty Attempt #{}: '.format(attempt_num))
            results = self._executor.read()
            if not self.is_empty(results):
                self._log_results(results, show_prompt=False)
            attempt_num += 1
            self.sleep(delay_time_seconds)

        self.sleep(5)

        return results

    def read_until_done(self, num_attempts=60, delay_time_seconds=1.0):
        success = False
        results = None
        attempt_num = 1

        while attempt_num < num_attempts and not self.is_done(results):
            logger.debug('Read Until Done #{}: '.format(attempt_num))
            results = self._executor.read()
            if not self.is_empty(results):
                self._log_results(results, show_prompt=False)
            if self._is_successful_response(results):
                success = True
            self._is_failure_response(results)
            attempt_num += 1
            self.sleep(delay_time_seconds)

        self.sleep(5)

        return success

    def read_until_not_busy(self, num_attempts=60, delay_time_seconds=1.0):
        attempt_num = 1
        results = {'busy':True}
        attempt_num = 1

        while attempt_num < num_attempts and self.is_busy(results):
            logger.debug('Read Until Not Busy Attempt #{}: '.format(attempt_num))
            results = self._executor.read()
            if not self.is_empty(results):
                self._log_results(results, show_prompt=False)
            attempt_num += 1
            self.sleep(delay_time_seconds)

        return results

    def execute(self, action):
        '''Executes an action in the metasploit interrupter
        Args:
            action(?): the action to execute
        Returns:
            bool: whether the attack was successful
        '''
        success = False

        if not self._executor.client:
            logger.error("Problem with executor instantiation")
            return False

        # Execute a single Meterpreter command (Disabling for now)
        if 'CMD' in action.keys():
            return
        #    return self.send_command(action['CMD'], read_type="until_done")

        # Set the Metasploit Module
        module = action['MODULE']
        command = 'use {}'.format(module)

        if not self.send_command(command):
            logger.error("Attempt to use module '{}' failed".format(module))
            return False

        # Set any Module Options
        for name, value in action.items():
            if name in ['PASSWORD','password','Password']:
                self._last_password = value
            if not name in ['MODULE']:
                command = 'set {} {}'.format(name, value)
                if not self.send_command(command):
                    logger.warning("Unable to set module option '{}' to '{}'".format(name, value))

        # Run the Metasploit Module
        if not self.send_command('run'):
            return False

        return True

    # Send a command to the executor.  Replace variables
    def send_command(self, command):
        command = command.replace('$session', str(self._current_session))
        command = command.replace('$password', str(self._last_password))
        self._log_line(command)
        self._executor.write(command, delay_time_seconds=1)
        
        return self.do_read()
    
    def _log_line(self, line):
        self._evidence.append("{}\n".format(line))

    def do_read(self, max_attempts=60):
        results = None
        attempts = 0
        while results == None and attempts < max_attempts:
            results = self.parse_read_results(self._executor.read())
            self.sleep(1)
            attempts += 1

        return results

    def parse_read_results(self, results):
        self._log_results(results)

        busy = results.get('busy', False)
        data = results.get('data', '')
        prompt = ""

        if 'prompt' in results.keys():
            prompt = results['prompt']

        if data == '' and not busy:
            return True

        # These are generic 'success' messages
        if re.search("(Backgrounding session|Starting interaction with|already interactive|Succeeded)", data):
            logger.debug("***Found generic success message***")
            return True

        # These are generic 'failure' messages
        if re.search("(RuntimeError|Failed|failed|no session was created)", data):
            logger.debug("***Found generic failure message***")
            return False

        if re.search(r"Meterpreter session \d+ opened", data):
            logger.debug("***Found Meterpreter session opened!***")
            return self.meterpreter_session_opened(data, prompt)

        if re.search(r"Command shell session \d+ opened", data):
            logger.debug("***Found Command shell session opened!***")
            return self.command_shell_opened(data)

        # Trigger for route added
        if re.search("Route added", data):
            logger.debug("***Found Route added!***")
            return self.route_added(data)

        # Detect when autoroute did not find any new routes
        if re.search("Did not find any new subnets", data):
            logger.debug("***No new subnets found, no route added.***")
            return True

        # Detect when a new host is found (ie. when arp scanning)
        if re.search("host found", data):
            logger.debug("***Host Found!***")
            return self.host_found(data)

        # Detect when an open port has been detected (ie. when port scanning)
        if re.search("TCP OPEN", data):
            logger.debug("***Open TCP Port Found!***")
            return self.open_port(data)

        return None

    def _sanitize(self, s):
        '''Remove any non-printable characters from a string
        Arguments:
            s (str): the string
        Returns:
            str: sanitized string
        '''
        return ''.join([c for c in s if c in string.printable])

    def _log_results(self, results, show_prompt=True):
        if not 'data' in results.keys() or results['data'] == '':
            return
        if show_prompt and 'prompt' in results.keys():
            line = '{}\n{}'.format(self._sanitize(results['data']), self._sanitize(results['prompt']))
        else:
            line = '{}\n'.format(self._sanitize(results['data']))
        self._evidence.append(line)

    def open_port(self, data):
        if self._exec_mode == 'black':
            ports = re.findall(" (.*?):(.*?) - TCP OPEN", data)
            for port in ports:
                self.do_port_detect(port[0], port[1])
        return True

    def do_port_detect(self, host, port):
        return True

    def route_added(self, data):
        if self._exec_mode == 'black':
            routes = re.findall("Route added to subnet (.*?) from", data)
            for route in routes:
                self.do_pingsweep(route)
        return True

    def host_found(self, data):
        if self._exec_mode == 'black':
            hosts = re.findall("     (.*?) host found", data)
            for host in hosts:
                self.do_portscan(host)
        return True

    def do_exploit_suggester(self):
        self.send_command("use post/multi/recon/local_exploit_suggester")
        self.send_command("set SESSION {}".format(self._current_session))
        return self.send_command("run")

    def do_portscan(self, host):
        self.send_command("use auxiliary/scanner/portscan/tcp")
        self.send_command("set RHOSTS {}".format(host))
        self.send_command("set PORTS {}".format(self._scan_ports))
        return self.send_command("run")

    def do_pingsweep(self, route):
        return self.send_command("run post/multi/gather/ping_sweep RHOSTS={}".format(route))

    def set_current_session_id(self, data):
        try:
            start = data.find("session") + 8
            end = data.find("opened") - 1
            self._current_session = int(data[start:end])
            return True
        except Exception as e:
            logger.error("Error setting session ID: {}".format(str(e)))
            return False

    def meterpreter_session_opened(self, data, prompt):
        if self._visualizations:
            self._visualizer.graph_advance(status=2)
        if not self.set_current_session_id(data):
            return False
        if self._exec_mode == 'single':
            return True
        self.sleep(5)
        # Ensure we are interacting with the meterpreter session
        if not self.send_command('sessions {}'.format(self._current_session)):
            logger.error("Could not interact with session")
            return False
        # Detect and create routes through host
        if not self.do_autoroute():
            logger.warning("Autoroute failed")
            return False
        # Background the session
        if not self.send_command('bg'):
            logger.warning("Could not background session")
        return True
        
    def command_shell_opened(self, data):
        if self._visualizations:
            self._visualizer.graph_advance(status=1)
        self.set_current_session_id(data)
        if self._exec_mode == 'single':
            return True
        # Attempt to sudo
        #if not self.do_sudo():
        #    logger.warning("Attempt to sudo w/in command shell failed")
        if not self.do_upgrade():
            logger.warning("Unable to upgrade command shell session to meterpreter")
            return False
        return True

    def do_sudo(self):
        self.send_command('use post/multi/manage/sudo')
        self.send_command('set SESSION $session')
        self.send_command('set PASSWORD $password')
        return self.send_command('run')

    def do_upgrade(self):
        return self.send_command('sessions -u $session')

    def do_autoroute(self):
        return self.send_command('run post/multi/manage/autoroute')

    def _is_failure_response(self, response):
        data = response['data']
        if self.failure_pattern.search(data) != None:
            logger.debug('*** Found failure in {}'.format(data))
            return True
        return False

    def _is_successful_response(self, response):
        data = response['data']
        success = False
        if self.success_pattern.search(data) != None:
            logger.debug('*** Found success in {}'.format(data))
            success = True
            if self.session_success_pattern.search(data) != None:
                start = data.find("session") + 8
                end = data.find("opened") - 1
                self._current_session = int(data[start:end])
                if self.command_shell_success_pattern.search(data) != None:
                    self.do_sudo()
                    if self.do_upgrade():
                        self.do_autoroute()
        return success

    def parse_values(self, values):
        '''Given a list of values from an attack step, parse it into an easily readable dictionary
        For example:
            values="module=auxiliary/scanner/scada/modbusclient rhost=192.168.10.250 action=WRITE_REGISTERS data_address=2 data_registers=30 unit_number=255"
            result={'MODULE': 'auxiliary/scanner/scada/modbusclient', 'RHOST': '192.168.10.250', 'ACTION': 'WRITE_REGISTERS',
                    'DATA_ADDRESS': '2', 'DATA_REGISTERS': '30', 'UNIT_NUMBER': '255'}
        Arguments:
            values(str): String describing the metasploit module and values
        Returns:
            dict: Dictionary of metasploit values to set
        '''
        result = {}
        if values.startswith('cmd'):
            return {'CMD':values.split('=')[1]}
        key_values = values.strip().split(' ')
        for key_value in key_values:
            if '=' in key_value:
                key, value = key_value.split('=')
                result[key.upper()] = value
            else:
                logger.error('Error: could not find enough values in "{}"'.format(values))
        logger.debug('parse_values: values={}, result={}'.format(values, result))
        return result

    def print_tree(self):
        for attack_tree in self.attack_trees:
            self._print_tree2(attack_tree)

    def _print_tree2(self, attack_tree):
        hop_list = attack_tree['hops']
        for hop_num, hop in enumerate(hop_list):
            node = hop['node']
            action_list = hop['actions']
            logger.debug('    Hop #{}, Node: {}'.format(hop_num, node))

            for action_num, action in enumerate(action_list):
                logger.debug('        Action #{}: {}'.format(action_num, action))
        logger.debug('================================================================')
