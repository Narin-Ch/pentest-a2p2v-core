#!/usr/bin/env python3
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Perspecta Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


import appdirs
import json
import logging
import os

from typing import List
from typing import Set

from collections import defaultdict
from csv import DictReader

from .config import appname
from .config import appauthor
from .config import config
from .msfrpc import MsfRpcClient

METASPLOIT_CONFIG_FILENAME = 'metasploit_config.json'

logger = logging.getLogger(__name__)

class MetasploitInfo:
    def __init__(self, module, name, rank, arch, module_type, description, targets):
        self.module = module
        self.name = name
        self.rank = rank
        self.arch = arch
        self.module_type = module_type
        self.description = description
        self.targets = targets

    def __str__(self):
        return 'module: {}\nname: {}\nrank: {}\narch: {}\nmodule_type: {}\ndescription: {}\ntargets: {}'.format(self.module,
            self.name, self.rank, self.arch, self.module_type, self.description, self.targets)

class MetasploitDB:
    data = None

    def __new__(cls):
        raise Exception('Cannot instantiate singleton class')

    @classmethod
    def _get_user_cache_dir(cls):
        '''Get the name of the user cache directory
        On Linux, this is $HOME/.cache/ourtool
        Returns:
            str: name of the user cache directory
        '''
        return appdirs.user_cache_dir(appname, appauthor)

    @classmethod
    def _get_user_config_dir(cls):
        '''Get the name of the user config directory
        On Linux, this is $HOME/.config/ourtool
        Returns:
            str: name of the user config directory
        '''
        return appdirs.user_config_dir(appname, appauthor)

    @classmethod
    def _get_db_filename(cls, filename):
        '''Get the full path and name of the configuration file
        On Linux, this is $HOME/.config/a2p2v/metasploit_config.json
        Returns:
            str: full path and name of the metasploit config file
        '''
        return os.path.join(cls._get_user_config_dir(), filename)

    @classmethod
    def load_data(cls):
        cls.load_broken_modules()
        cls.load_details()

    @classmethod
    def load_broken_modules(cls):
        cls.broken_modules = set()
        broken_modules = config.get('METASPLOIT', 'broken_modules', fallback='None').replace('"', '').replace("'", "")

        for broken_module in broken_modules.split(' '):
            logger.info('Broken module %s', broken_module)
            cls.broken_modules.add(broken_module)

    
    @classmethod
    def sanitize(cls, s):
        return s.replace("'", "").replace('"', '').strip()

    @classmethod
    def load_details(cls, only_allowed_modules=True):
        # Get the name of the DB details file
        details_db_filename = cls._get_db_filename(METASPLOIT_CONFIG_FILENAME)

        # If the config file does not already exist, pull it using the Metasploit API
        if not os.path.isfile(details_db_filename):
            rpc_client = MsfRpcClient()
            rpc_client.create_metasploit_config(details_db_filename, only_allowed_modules)

        # Load the config
        cls.data = cls.load_data_from_file(details_db_filename)

        # Store the data in internal dictionaries
        cls.names = {}
        cls.modules = {}
    
        # Ban certain entries
        for entry in cls.broken_modules:
            try:
                logger.debug('Removing MSF details for %s', entry)
                cls.data.pop(entry)
            except KeyError as e:
                logger.debug('Did not find %s in details', entry)

        # Create a lookup table for CVEs
        cves_temp = defaultdict(list)
        cls.name_to_cvelist = defaultdict(list)

        # Create a lookup table
        for fullname, info in cls.data.items():

            # Obtain the metasploit name, e.g. "Dynamic key XOR Encoder"
            name = cls.sanitize(info.get('name', ''))

            # Populate a mapping
            cls.modules[fullname] = info
            cls.names[name] = info

            # Store CVE information
            cves = info.get('cves', [])
            for cve in cves:
                cve_id = f'CVE-{cve}'
                cves_temp[cve_id].append(fullname)
                cls.name_to_cvelist[name].append(cve_id)

        # Convert to a regular dictionary
        cls.cves = dict(cves_temp)
    
    @classmethod
    def load_data_from_file(cls, dbfile):
        with open(dbfile, 'rb') as f:
            return json.load(f)
    
    @classmethod
    def get_name_by_module(cls, module_name):
        # Support lazy loading of the data
        if cls.data == None:
            cls.load_data()

        name = None
        try:
            name = cls.modules[module_name]['name']
        except KeyError as e:
            logger.debug('Error: get_name_by_module({}) found no results'.format(module_name))

        logger.debug('get_name_by_module(%s) = %s', module_name, name)

        return name

    @classmethod
    def get_module_by_name(cls, name):
        # Support lazy loading of the data
        if cls.data == None:
            cls.load_data()

        module_name = 'Unknown'
        try:
            if name:
                module_name = cls.names[cls.sanitize(name)]['fullname']
        except KeyError as e:
            logger.debug('get_module_by_name({}) found no results'.format(name))
            pass

        logger.debug('get_module_by_name(%s) = %s', name, module_name)
        return module_name

    @classmethod
    def get_names_by_cve_number(cls, cve_number: str) -> List[str]:
        """Get a list of names associated with a CVE
        Arguments:
            cve_number (str): CVE number, e.g. CVE-2017-0143
        Returns:
            List[str]: List of related module names, e.g.
            ['DOUBLEPULSAR Payload Execution and Neutralization',
            'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption',
            'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption for Win8+',
            'MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution',
            'MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution',
            'MS17-010 SMB RCE Detection']
        """

        module_list = cls.get_modules_by_cve_number(cve_number)
        name_list = [cls.get_name_by_module(module) for module in module_list]
        return name_list

    @classmethod
    def get_related_modules_by_module(cls, module: str) -> Set[str]:
        related_modules = set()
        info = cls.get_info_by_module(module)
        if info:
            related_modules = cls.get_related_modules_by_name(info.name)

        return related_modules

    @classmethod
    def get_related_modules_by_name(cls, name: str) -> Set[str]:
        '''Get a list of all module names related to a name
        Arguments:
            name (str): A metasploit name e.g.
            'MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution'
        Returns:
            List[str]: List of related module names, e.g.
            ['exploit/windows/smb/doublepulsar_rce',
            'exploit/windows/smb/ms17_010_eternalblue',
            'exploit/windows/smb/ms17_010_eternalblue_win8',
            'exploit/windows/smb/ms17_010_psexec',
            'auxiliary/admin/smb/ms17_010_command',
            'auxiliary/scanner/smb/smb_ms17_010']
        '''
        related_modules = set()
        cve_list = cls.get_cvelist_by_name(name)
        for item in cve_list:
            for name in cls.get_modules_by_cve_number(item):
                related_modules.add(name)

        return related_modules

    @classmethod
    def get_modules_by_cve_number(cls, cve_number: str) -> List[str]:
        '''Get a list of all module names related to a CVE
        Arguments:
            cve_number (str): CVE number, e.g. CVE-2017-0143
        Returns:
            List[str]: List of related module names, e.g.
            ['exploit/windows/smb/doublepulsar_rce',
            'exploit/windows/smb/ms17_010_eternalblue',
            'exploit/windows/smb/ms17_010_eternalblue_win8',
            'exploit/windows/smb/ms17_010_psexec',
            'auxiliary/admin/smb/ms17_010_command',
            'auxiliary/scanner/smb/smb_ms17_010']
        '''
        # Support lazy loading of the data
        if cls.data == None:
            cls.load_data()

        module_name_list = []
        try:
            module_name_list = cls.cves[cve_number.upper()]
        except KeyError as e:
            logger.debug('get_modules_by_cve_number({}) found no results'.format(cve_number))

        logger.debug('get_modules_by_cve_number(): cve_number: {}, module_name_list: {}'.format(cve_number,
            module_name_list))

        return module_name_list

    @classmethod
    def get_options_by_module(cls, module_name):
        options = None

        # Support lazy loading of the data
        if cls.data == None:
            cls.load_data()

        try:
            options = cls.data.get(module_name, {}).get('options', {})
        except KeyError as e:
            logger.debug('Error: get_options_by_module({}) found no results'.format(module_name))

        logger.debug('get_options_by_module(%s) =  %s', module_name, options)
        return options

    @classmethod
    def get_info_by_module(cls, module_name):
        info = None

        # Support lazy loading of the data
        if cls.data == None:
            cls.load_data()

        try:
            module_details = cls.data[module_name]
            info = MetasploitInfo(module=module_name,
                name=module_details.get('name', ''),
                rank=module_details.get('rank', ''),
                arch=module_details.get('arch', ''),
                module_type=module_details.get('type', ''),
                targets=module_details.get('targets', ''),
                description=module_details.get('description', '')
                )
        except KeyError as e:
            logger.debug('Warning: get_info_by_module({}) found no results'.format(module_name))

        logger.debug('get_info_by_module(%s): info=%s', module_name, info)

        return info

    @classmethod
    def get_options_by_name(cls, name):
        module_name = cls.get_module_by_name(name)
        return cls.get_options_by_module(module_name)

    @classmethod
    def get_related_names_by_name(cls, name: str) -> Set[str]:
        """Given a metasploit name, return all related names
        Arguments:
            name (str): A metasploit name e.g.
            'MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution'

        Returns:
            Set[str]: related names e.g.
            {
            'DOUBLEPULSAR Payload Execution and Neutralization',
            'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption',
            'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption for Win8+',
            'MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution',
            'MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution',
            'MS17-010 SMB RCE Detection'
            }
        """
        related_names = set()
        cve_list = cls.get_cvelist_by_name(name)
        for item in cve_list:
            for name in cls.get_names_by_cve_number(item):
                related_names.add(name)

        return related_names

    @classmethod
    def get_related_names_by_cve(cls, cve: str) -> Set[str]:
        """Given a cve name, return all related names
        Arguments:
            cve (str): CVE, e.g. CVE-2017-0143
        Returns:
            Set[str]: related names e.g.
            {
            'DOUBLEPULSAR Payload Execution and Neutralization',
            'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption',
            'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption for Win8+',
            'MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution',
            'MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution',
            'MS17-010 SMB RCE Detection'
            }
        """
        related_names = set()

        for name in cls.get_names_by_cve_number(cve):
            related_names.add(name)
        return related_names

    @classmethod
    def get_cvelist_by_name(cls, name):
        # Support lazy loading of the data
        if cls.data == None:
            cls.load_data()

        cvelist = None

        try:
            cvelist = cls.name_to_cvelist[name]
        except KeyError as e:
            logger.debug('Error: get_cvelist_by_name({}) found no results'.format(name))

        logger.debug('get_cvelist_by_name(%s) = %s', name, cvelist)

        return cvelist

    @classmethod
    def clean(cls):
        '''Remove the previous
        '''
        for filename in [METASPLOIT_CONFIG_FILENAME]:
            full_filename = cls._get_db_filename(filename)
            if os.path.isfile(full_filename):
                logger.info('Removing file %s', full_filename)
                os.remove(full_filename)
                cls.load_broken_modules()
                cls.load_details(only_allowed_modules=False)
            else:
                logger.info('File %s does not exist', full_filename)


def main():
    logger.setLevel('DEBUG')
    ch = logging.StreamHandler()
    ch.setLevel('DEBUG')

    # create formatter
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    #print(MetasploitDB.get_options_by_module("post/multi/gather/ping_sweep"))
    #print(MetasploitDB.get_options_by_module('exploit/multi/http/wp_ninja_forms_unauthenticated_file_upload'))

    # Attempt DOES NOT EXIST use cases
    #print(MetasploitDB.get_name_by_module('DOESNOTEXIST'))
    #print(MetasploitDB.get_modules_by_cve_number('DOESNOTEXIST'))
    #print(MetasploitDB.get_options_by_module('DOESNOTEXIST'))
    #print(MetasploitDB.get_options_by_name('DOESNOTEXIST'))
    #print(MetasploitDB.get_cvelist_by_name('DOESNOTEXIST'))

    # Attempt normal use cases
    print(MetasploitDB.get_name_by_module('exploit/windows/smb/ms17_010_eternalblue'))
    print(MetasploitDB.get_module_by_name('MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption'))
    print(MetasploitDB.get_options_by_module('exploit/windows/smb/ms17_010_eternalblue'))
    print(MetasploitDB.get_options_by_module('exploit/windows/smb/ms17_010_psexec'))
    print(MetasploitDB.get_options_by_module('auxiliary/scanner/ssh/ssh_login'))
    print(MetasploitDB.get_options_by_name('MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption'))
    #print(MetasploitDB.get_options_by_module("post/multi/gather/ping_sweep"))
    print(MetasploitDB.get_options_by_module('exploit/multi/http/wp_ninja_forms_unauthenticated_file_upload'))

    print(MetasploitDB.get_modules_by_cve_number('CVE-2017-14937'))
    print(MetasploitDB.get_modules_by_cve_number('CVE-2017-0147'))
    print(MetasploitDB.get_modules_by_cve_number('CVE-1999-0651'))
    print(MetasploitDB.get_modules_by_cve_number('CVE-2019-0708'))

    print("Trouble calls")
    #print(MetasploitDB.get_module_by_name("glibc '$ORIGIN' Expansion Privilege Escalation"))
    #print(MetasploitDB.get_module_by_name("glibc 'realpath()' Privilege Escalation"))
    #print(MetasploitDB.get_module_by_name('glibc "$ORIGIN" Expansion Privilege Escalation'))
    #print(MetasploitDB.get_module_by_name('glibc "realpath()" Privilege Escalation'))
    #print(MetasploitDB.get_module_by_name("glibc $ORIGIN Expansion Privilege Escalation"))
    #print(MetasploitDB.get_module_by_name("glibc realpath() Privilege Escalation"))

    trouble_names = ['Oracle Weblogic Server Deserialization RCE - AsyncResponseService ',
            ' Microsoft IIS WebDav ScStoragePathFromUrl Overflow']

    for name in trouble_names:
        print("'{}': {}".format(name, MetasploitDB.get_module_by_name(name)))
        print("'{}': {}".format(name.strip(), MetasploitDB.get_module_by_name(name.strip())))

    # The following should NOT be called directly:
    # print(MetasploitDB.modules['exploit/windows/smb/ms17_010_eternalblue'])
    # print(MetasploitDB.names['MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption'])
    print(MetasploitDB.get_cvelist_by_name('MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption'))
    print(MetasploitDB.get_cvelist_by_name('MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution'))

    print(MetasploitDB.get_info_by_module('exploit/windows/smb/ms17_010_psexec'))

if __name__ == '__main__':
    main()

# TODO
#
# - Add remaining methods to MetasploitDB
# - Check for expired cache
# - Modify code to accept other nessus file and capabilities file
# - Test in docker
