#!/usr/bin/env python3
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Perspecta Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# coding: utf-8

import logging

import queue
import time

from .config import config

logger = logging.getLogger(__name__)


class Simulator(object):
    def __init__(self):
        '''Simulator class provides all the same methods as Executor
        '''
        # Create a new metasploit client
        self._console = None
        self._console_id = None
        self.client = "FakeClient"

        self.valid = True
        self._responses = queue.SimpleQueue()
        self._run_responses = queue.SimpleQueue()
        self._session_num = 0
        self._prompt = 'msf5 simulator> '

        self._add_response('Metasploit Started\n')

    def _destroy_console(self):
        '''Remove the current metasploit console
        '''
        logger.debug('_destroy_console(): called')

    def _create_console(self):
        '''Create a metasploit console
        '''
        self._console_id = 0

    def write(self, message, delay_time_seconds=None):
        '''Write a message to the metasploit console
        Arguments:
            message (str): the message to send to metasploit
            delay_time_seconds (int): Optional delay to wait after sending message
        '''
        logger.debug('Writing message: \'{}\''.format(message))

        if 'exploit' in message:
            self._session_num += 1
            self._add_run_response(f'\n[*] Executing exploit\n[+] Meterpreter session {self._session_num} opened')
        elif 'sessions -u' in message:
            self._session_num += 1
            self._add_response(f'\n[*] Executing post/multi/manage/shell_to_meterpreter\n', busy=True)
            self._add_response(busy=True)
            self._add_response(f'\n[*] Meterpreter session {self._session_num} opened\n', busy=True)
        elif 'sessions' in message:
            _, session_num = message.split(' ')
            self._add_response(f'\n[*] Activating session {session_num}\n', busy=False)
        elif 'ssh' in message:
            self._session_num += 1
            self._add_run_response(f'\n[+] Success\n[+] Command shell session {self._session_num} opened')
        elif 'set' in message:
            _, name, value = message.split(' ')
            self._add_response(f'{name} => {value}\n')
        elif 'auxiliary' in message:
            self._add_run_response(f'\n[*] Succeeded\n[*] Auxiliary module execution completed')
        elif message == 'run post/multi/manage/autoroute':
            self._add_response('\n[+] Route added.\n')
        elif message == 'bg':
            self._add_response(f'\n[*] Backgrounding session {self._session_num}.\n')
        elif 'run' in message or 'exploit' in message:
            self._add_response('Simulated run', busy=True)

        # TODO: Depending on the message, append to the output queue
        if delay_time_seconds != None:
            self.delay(delay_time_seconds)

    def _add_response(self, msg: str = '', prompt: str = None, busy:bool = False):
        if not prompt:
            prompt = self._prompt
        response = self._format_response(msg, prompt, busy)
        logger.debug('_add_response %s', response)
        self._responses.put(response)

    def _add_run_response(self, msg: str = '', prompt: str = None, busy:bool = False):
        if not prompt:
            prompt = self._prompt
        response = self._format_response(msg, prompt, busy)
        logger.debug('_add_run_response %s', response)
        self._run_responses.put(response)

    def _format_response(self, msg:str = '', prompt:str = None, busy:bool = False) -> dict:
        if not prompt:
            prompt = self._prompt
        response = { 'data': msg, 'prompt': prompt, 'busy': busy }
        return response

    def _get_response(self):
        if not self._responses.empty(): 
            msg = self._responses.get_nowait()
            if msg is None:
                logger.error('Found None on response queue')
        else:
            logger.debug('Empty response')
            msg = { 'data': '', 'prompt': self._prompt, 'busy': False }

        return msg

    def read(self):
        '''Read the response from the message queue
        Returns:
            dict: Response from metasploit API, dictionary containing 'data' and 'prompt'
        '''

        response = self._get_response()

        logger.debug('read(): response = %s', response)
        if response and response.get('data', '') == 'Simulated run':
            while not self._run_responses.empty():
                new_response = self._run_responses.get_nowait()
                logger.debug('Adding response %s', new_response)
                if new_response:
                    self._responses.put(new_response)

        logger.debug('Read message %s', response)

        return response

    def delay(self, time_seconds=1):
        '''Sleep a specified amount of time:
        Arguments:
            time_seconds (int): time to sleep in seconds
        '''
        #time.sleep(time_seconds)
        pass

    def stop_session(self, session_number):
        '''Stop a meterpreter or other session
        Arguments:
            session_number (int): the meterpreter session number to stop
        '''
        logger.debug('Stopping session #{}'.format(session_number))

    def stop_all_sessions(self):
        '''Stop all meterpreter or other sessions'''
        pass


def main():
    with Executor() as executor:
        print(executor.read())
        executor.write('show options')
        print(executor.read())

if __name__ == '__main__':
    main()
