#!/usr/bin/python3.7
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Perspecta Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import logging, time, sys, csv, re, operator
from enum import IntEnum
import os
import xml.etree.ElementTree as ET 
import networkx as nx
import sqlite3

from .database import get_database_filename
from .config import config
from .metasploitdb import MetasploitDB

__VERSION__ = '0.3'

logger = logging.getLogger(__name__)


# Used to assign numeric values to compare access levels
class CapabilityRank(IntEnum):
    excellent = 10
    great = 9
    good = 8
    normal = 7
    average = 6
    low = 5
    manual = 4
    unknown = 3
    disabled = 0
    banned = 0
    broken = 0

####################
# Helper Functions #
####################

truth_values = set(['True', 'true', 1, '1'])

##########################################

# Each capability is an instantiation of this class
class Capability(object):
    def __init__(self, capID, capTitle, cclass, csubclass, severity, cvelist, cvss, preconditions, actions, postconditions, rank, solution):
        self.capabilityID = capID		# Unique ID (module for metasploit module)
        self.capabilityTitle = capTitle		# Human readable title for the capability
        self.capabilityClass = cclass           # exploit or service
        self.capabilitySubClass = csubclass     # service name or or exploit type (remote_code execution, privilege_escalation)
        self.capabilitySeverity = int(severity)	# Severity level (0-4)
        self.capabilitySolution = solution	# Suggested solution / remediation (for reporting)
        self.capabilityRank = rank		# How reliable the capability is (can be from Metasploit info)
        self.capabilityCVEs = cvelist		# List of relevant CVEs
        self.capabilityCVSS = cvss		# CVSS if applicable
        self.preconditions = preconditions	# List of preconditions
        self.actions = actions			# List of actions
        self.postconditions = postconditions	# List of postconditions

    def __str__(self):
        return 'Capability(ID="{}", Title="{}", Class="{}", SubClass="{}", Severity="{}", Solution="{}", Rank="{}", CVEs="{}", CVSS="{}", Preconditions={}, Actions={}, Postconditions={})'.format(self.capabilityID, self.capabilityTitle, self.capabilityClass, self.capabilitySubClass, self.capabilitySeverity, self.capabilitySolution, self.capabilityRank, self.capabilityCVEs, self.capabilityCVSS, self.preconditions, self.actions, self.postconditions)

    def __repr__(self):
        return self.__str__()

# A single instantiation of the analyzer which performs parsing of various configuration files and gets capabilities from database
class Analyzer:
    def __init__(self, execute, plan, datafile=None, netfile=None):
        self.plan = plan
        self.execute = execute

        self.capabilities = {}
        self.hostsDB = {}
        self.networkGraph = nx.Graph()
        self.datafile = datafile
        self.network_rep = netfile
        self.dbconn = None
        self.unknown_services = {}

        if not self.get_config_options() or not self.connect_to_database() or not self.test_metasploit():
            self.valid = False
        else:
            self.valid = True
            self.get_capabilities_from_database()
    
    # A quick test to see if Metasploit cache is available or API is available
    def test_metasploit(self):
        try:
            MetasploitDB.get_name_by_module(True)
            return True
        except Exception as e:
            logger.error("Unable to query Metasploit module info ({})".format(e))
            return False

    def connect_to_database(self):
        database_file = get_database_filename()
        if not os.path.isfile(database_file):
            logger.error('No capabilities database loaded')
            logger.error('To load: a2p2v --importdb <filename>')
            return False

        self.dbconn = sqlite3.connect(database_file)
        return True

    def database_execute_query(self, query, commit=False):
        rows = None
        cursor = self.dbconn.cursor()
        try:
            cursor.execute(query)
        except Exception as e:
            logger.debug("{} ({})".format(str(e), query))

        if commit:
            self.dbconn.commit()
        else:
            rows = cursor.fetchall()

        cursor.close()
        return rows

    # For a give target IP address returns the associated hostname.  If the target is not in the hosts database, simply return it.
    def ip_to_hostname(self, target):
        if not target in self.hostsDB.keys():
            for host, hostDetails in self.hostsDB.items():
                if target in [interface[0] for interface in hostDetails['interfaces']]:
                    logger.debug("IP address {} resolved to host {}".format(target, host))
                    target = host

        return target.upper()

    def get_config_options(self):
        try:
            if self.datafile == None:
                self.datafile = config.get('INPUT', 'default_datafile')
            logger.info('Using datafile: {}'.format(self.datafile))

            if self.plan and self.network_rep == None:
                # TODO: Auto-detection of representation_type
                #self.network_plugin = config.get('INPUT','representation_type')
                self.network_rep = config.get('INPUT','default_netfile')
        except Exception as e:
            logger.error("Error Reading Configuration File: {}".format(e))
            return False

        return True

    # Associates a capability with a host if not already associated    
    def add_capabilities_to_host(self, host, capability_names):
        host = self.ip_to_hostname(host)

        for capability_name in capability_names:
            capability = self.capabilities.get(capability_name, None)
            if capability is None:
                logger.error('Could not find capability %s', capability_name)
            elif capability.capabilityClass == 'banned':
                logger.debug('Banned from DB, capability_name %s', capability_name)
            #if self.has_banned_actions(capability):
            #   logger.debug('Banned capability_name %s', capability_name)
            elif not capability_name in self.hostsDB[host]['capabilities']:
                self.hostsDB[host]['capabilities'].append(capability_name)
                logger.debug("Associated capability_name {} with {}".format(capability_name, host))
  
    def run(self):
        self._detect_plugin_type()

        if self.plan:
            logger.info("Parsing Network Representation Using Internal Plugin")
            self.parse_network_xml(self.network_rep)

        if self.scan_plugin == 'nessus':
            logger.info("Parsing Nessus Results")
            # Convert .nessus to .common format
            commonDictList = self.parse_nessus_xml()
            # Save .common format file
            self.write_common_csv(commonDictList, 'nessus')
        elif self.scan_plugin == 'common':
            logger.info("Parsing Common Format Results")
            commonDictList = self.parse_common_csv()
        elif self.scan_plugin == 'nmap':
            logger.info("Parsing Nmap Format Results")
            # Convert .nmap to .common format
            commonDictList = self.parse_nmap_xml()
            # Save .common format file
            self.write_common_csv(commonDictList, 'nmap')
        else:
            logger.error("Unsupported Scan Plugin: {}".format(self.scan_plugin))
            return 0

        logger.debug("Host DB: {}".format(self.hostsDB))

        if not self.read_common(commonDictList):
            return 0

        self.report_capabilities()

        return 1

    def _detect_plugin_type(self):
        self.scan_plugin = 'unknown'
        # Determine the plugin type
        with open(self.datafile, 'r') as datafile:
            data = datafile.read()
            if 'NessusClientData' in data:
                self.scan_plugin = 'nessus'
            elif '"hostname","hostip","hostcpe","protocol","port","type","name","class","rank","severity","cvss","solution"' in data:
                self.scan_plugin = 'common'
            elif 'DOCTYPE nmaprun' in data:
                self.scan_plugin = 'nmap'
            else:
                self.scan_plugin = 'unknown'
        logger.info('Detected scan type: {}'.format(self.scan_plugin))

    def parse_network_xml(self, nxmlfile):
        tree = ET.parse(nxmlfile)
        root = tree.getroot()

        hosts = root.findall("hosts/host")
        connections = root.findall("connections/connection")


        for host in hosts:
            nodeID = host.attrib['id'].upper()
            logger.debug('host.nodeID={}'.format(nodeID))
            nodePassive = host.attrib['passive'] in truth_values
            if not nodeID in self.hostsDB.keys() and not nodePassive:
                self.hostsDB[nodeID] = {'interfaces':set(), 'capabilities':[], 'cpe':''}
            if nodePassive:
                self.networkGraph.add_node(nodeID, nodeID=nodeID, nodePassive=nodePassive, nodeType="switch")
            else:
                self.networkGraph.add_node(nodeID, nodeID=nodeID, nodePassive=nodePassive, nodeType="host")
            interfaces = host.findall("interfaces/interface")
            for interface in interfaces:
                interfaceID = interface.attrib['id'].upper()
                interfaceIP = interface.attrib['ip']
                interfaceMAC = interface.attrib['mac']
                logger.debug('    interface={} {} {}'.format(interfaceID, interfaceIP, interfaceMAC))
                self.hostsDB[nodeID]['interfaces'].add((interfaceIP, interfaceMAC))
                self.networkGraph.add_node(interfaceID, nodeID=interfaceIP, nodePassive=True, nodeType="interface")
                self.networkGraph.add_edge(nodeID, interfaceID, route=False, weight=1, length=.5)
            routes = host.findall("routes/route")
            for route in routes:
                src_id = route.attrib['src_id'].upper()
                dst_id = route.attrib['dst_id'].upper()
                logger.debug('    route={} {}'.format(src_id, dst_id))
                self.networkGraph.add_edge(src_id, dst_id, route=True, weight=1, length=2)

        for connection in connections:
            startNode = connection.attrib['begin'].upper()
            endNode = connection.attrib['end'].upper()
            self.networkGraph.add_edge(startNode, endNode, route=False, weight=1, length=4)
            logger.debug('connection: start={}, end={}'.format(startNode, endNode))

        logger.debug('nodes={}'.format(self.networkGraph.nodes))
        logger.debug('edges={}'.format(self.networkGraph.edges))

    def write_capability_to_database(self, capability):
        capabilityInsert = "INSERT INTO capability VALUES('{}', '{}', '{}', '{}', {}, '{}', '{}', '{}', '{}');".format(capability.capabilityID, capability.capabilityTitle, capability.capabilityClass, capability.capabilitySubClass, capability.capabilitySeverity, capability.capabilityCVSS, capability.capabilityRank, capability.capabilitySolution, capability.capabilityCVEs)

        self.database_execute_query(capabilityInsert, commit=True)
      
        for precondition in capability.preconditions:
            preconditionInsert = "INSERT INTO pap VALUES('{}', 'precondition', '{}', '{}', '{}', '{}');".format(capability.capabilityID, precondition['host'], precondition['type'], precondition['key'], precondition['value'])
            self.database_execute_query(preconditionInsert, commit=True)

        for action in capability.actions:
            actionInsert = "INSERT INTO pap VALUES('{}', 'action', '', '{}', '{}', '{}');".format(capability.capabilityID, action['type'], action['key'], action['value'])
            self.database_execute_query(actionInsert, commit=True)

        for postcondition in capability.postconditions: 
            postconditionInsert = "INSERT INTO pap VALUES('{}', 'postcondition', '', '{}', '{}', '{}');".format(capability.capabilityID, postcondition['type'], postcondition['key'], postcondition['value'])
            self.database_execute_query(postconditionInsert, commit=True)

    def get_capabilities_from_database(self):
        selectQuery = "SELECT * FROM capability"
        result = self.database_execute_query(selectQuery)

        for capability in result:
            (capabilityID, capabilityTitle, capabilityClass, capabilitySubClass, capabilitySeverity, capabilityCVSS, capabilityRank, capabilitySolution, capabilityCVEs) = capability

            preconditions = []
            dbPreconditions = self.database_execute_query("SELECT pap_host,pap_type,pap_key,pap_value FROM pap WHERE capability_id = '{}' and pap_class = 'precondition'".format(capabilityID))
            for precondition in dbPreconditions:
                (phost, ptype, pkey, pvalue) = precondition
                iprecondition = {'host':phost, 'type':ptype, 'key':pkey, 'value':pvalue}
                preconditions.append(iprecondition)

            actions = []
            dbActions = self.database_execute_query("SELECT pap_type,pap_key,pap_value FROM pap WHERE capability_id = '{}' and pap_class = 'action'".format(capabilityID))
            for action in dbActions:
                (atype, akey, avalue) = action
                iaction = {'type':atype, 'key':akey, 'value':avalue}
                actions.append(iaction)

            postconditions = []
            dbPostconditions = self.database_execute_query("SELECT pap_type,pap_key,pap_value FROM pap WHERE capability_id = '{}' and pap_class = 'postcondition'".format(capabilityID))
            for postcondition in dbPostconditions:
                (ptype, pkey, pvalue) = postcondition
                ipostcondition = {'type':ptype, 'key':pkey, 'value':pvalue}
                postconditions.append(ipostcondition)

            self.add_capability(capabilityID, capabilityTitle, capabilityClass, capabilitySubClass, capabilitySeverity, capabilityCVEs, capabilityCVSS, preconditions, actions, postconditions, rank=capabilityRank, solution=capabilitySolution)

        logger.info("Loaded {} capabilities from database".format(len(result)))


    # Instantiates and adds new capability to global list as well as database if it doesn't exist.
    def add_capability(self, capabilityID, ctitle, cclass, csubclass, cseverity, ccves, ccvss, precons, actions, postcons, rank, solution, db=False):
        if not capabilityID in self.capabilities.keys():
            newCapability = Capability(capabilityID, ctitle, cclass, csubclass, cseverity, ccves, ccvss, precons, actions, postcons, rank=rank, solution=solution)
            self.capabilities[capabilityID] = newCapability

            if db:
                logger.info("Adding New Capability to Database: {}".format(ctitle))
                self.write_capability_to_database(newCapability)

    def match_service_capability(self, protocol, port):
        # Disregard services if port is '0'.  This implies the service was found via authenticated scan, but isn't running.
        if port == '0':
            return []
        matched_capabilities = []
        protocolPort = "{}/{}".format(protocol.lower(), port)
        for capability_name, capability in self.capabilities.items():
            if capability.capabilityClass == 'service':
                for condition in capability.preconditions:
                    if condition['type']  == 'service' and condition['value'] == protocolPort:
                        logger.debug("Matched {} for {}/{}".format(capability_name, protocol, port))
                        matched_capabilities.append(capability_name)
                    elif condition['type'] == 'capability':
                        capSplit = '.'.join(capability_name.split('.')[:-1])
                        if capSplit in matched_capabilities:
                            matched_capabilities.append(capability_name)

        return matched_capabilities

    def add_metasploit_capability(self, hostName, severity, cvss, cclass, rank, name_or_module, protocol, port, solution):
        # Assume the module is provided and look up the name
        module = name_or_module
        name = MetasploitDB.get_name_by_module(module)

        # If the module is unknown, assume the name was provided
        if not name:
            # The name was provided, look up module name
            name = name_or_module
            module = MetasploitDB.get_module_by_name(name_or_module) 

        logger.debug('module = %s, name = %s', module, name)

        cves = ','.join(MetasploitDB.get_cvelist_by_name(name))

        if module == 'Unknown':
            logger.error("Metasploit name '{}' for host {} not found in Metasploit DB cache.  This could be due to a mismatch between Metasploit name in ".format(name, hostName) + \
                         "scan data and Metasploit name in the current version of the Metasploit DB.  Consider updating Metasploit DB cache.")
            return False

        metasploitOptions = MetasploitDB.get_options_by_module(module)

        actualOptions = self.fix_metasploit_options(metasploitOptions)

        actions = [{"type":"metasploit", "key":cclass, "value":"module={} {}".format(module, actualOptions)}]
        templateCapability = self.capabilities[cclass]
        for condition in templateCapability.preconditions:
            if condition['type'] == 'service':
                condition['value'] = '{}/{}'.format(protocol, port)
        self.add_capability(module, name, "exploit", cclass, severity, cves, cvss, templateCapability.preconditions, actions, templateCapability.postconditions, rank, solution, db=True)
        self.add_capabilities_to_host(hostName, [module])

        return True

    def add_service_capability(self, hostName, protocol, port):
        matched_capabilities = self.match_service_capability(protocol, port)

        if matched_capabilities:
            self.add_capabilities_to_host(hostName, matched_capabilities)
        else:
            protocolPort = "{}/{}".format(protocol.lower(), port)
            if protocolPort in self.unknown_services.keys():
                self.unknown_services[protocolPort].add(hostName)
            else:
                self.unknown_services[protocolPort] = {hostName}

        return True

    def parse_default(self, hostName, hostIP, hostCPE):
        logger.debug("Examining results for host: {}".format(hostName))
        if hostName in self.hostsDB.keys():
            self.hostsDB[hostName]['interfaces'].add((hostIP,''))
            if not self.hostsDB[hostName]['cpe']:
                self.hostsDB[hostName]['cpe'] = hostCPE
        else:
            self.hostsDB[hostName] = {'interfaces':{(hostIP,'')}, 'cpe':hostCPE, 'capabilities':[]}

    def parse_common_csv(self):
        commonDictList = []
        with open(self.datafile, 'r', newline='') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                commonDictList.append(dict(row))

        return commonDictList

    def write_common_csv(self, commonDictList, inputType):
        filename = "{}_{}_{}.common".format(self.datafile.split('.')[0], inputType, 'converted')
        logger.info("Writing converted {} input file to: {}".format(inputType, filename))
        with open(filename, 'w', newline='') as csvfile:
            fieldnames = list(commonDictList[0].keys())
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames, quoting=csv.QUOTE_ALL)
            writer.writeheader()
            for item in commonDictList:
                writer.writerow(item)

    def read_common(self, commonDictList):
        for item in commonDictList:
            hostName = item['hostname'].upper()
            hostIP = item['hostip']
            hostCPE = item['hostcpe']
            name = item['name']
            solution = item['solution']
            protocol = item['protocol']
            port = item['port']
            itemType = item['type']
            itemClass = item['class']
            severity = item['severity']
            cvss = item['cvss']
            rank = item['rank']

            if not hostName:
                hostName = hostIP

            self.parse_default(hostName, hostIP, hostCPE)

            if itemType == 'service':
                if not self.add_service_capability(hostName, protocol, port):
                    return False
            elif itemType == 'exploit':
                if not self.add_metasploit_capability(hostName, severity, cvss, itemClass, rank, name, protocol, port, solution):
                    return False

        return True

    def build_common_service(self, hostName, hostIP, hostCPE, protocol, port, service_name, commonOut):
        matched_capabilities = self.match_service_capability(protocol, port)

        if not matched_capabilities:
            if not self.check_duplicate(commonOut, hostName, protocol=protocol, port=port):
                commonEntry = {"hostname":hostName, 
                               "hostip":hostIP,
                               "hostcpe":hostCPE,
                               "protocol":protocol, 
                               "port":port, 
                               "type":"service",
                               "name":service_name, 
                               "class":service_name, 
                               "rank":CapabilityRank['normal'].value,
                               "severity":"0", 
                               "cvss":"", 
                               "solution":"Ensure this service is properly secured."}
                commonOut.insert(0,commonEntry)
        else:
            for capability in matched_capabilities:
                capability = capability.split('.')[0]
                capabilityInstance = self.capabilities[capability]
                if capabilityInstance.capabilityClass == 'service':
                    service_name = capabilityInstance.capabilityTitle
                    if not self.check_duplicate(commonOut, hostName, protocol=protocol, port=port):
                        commonEntry = {"hostname":hostName,
                                       "hostip":hostIP,
                                       "hostcpe":hostCPE,
                                       "protocol":protocol,
                                       "port":port,
                                       "type":"service",
                                       "name":service_name, 
                                       "class":capabilityInstance.capabilitySubClass, 
                                       "rank":capabilityInstance.capabilityRank,
                                       "severity":capabilityInstance.capabilitySeverity,
                                       "cvss":capabilityInstance.capabilityCVSS,
                                       "solution":capabilityInstance.capabilitySolution}
                        logger.debug("Adding common service: {}".format(commonEntry))
                        commonOut.insert(0,commonEntry)

        return commonOut

    def build_common_exploit(self, hostName, hostIP, hostCPE, protocol, port, metasploitName, description, cvss, severity, solution, commonOut):
        metasploit_module = MetasploitDB.get_module_by_name(metasploitName)
        if not self.check_duplicate(commonOut, hostName, name=metasploit_module):
            metasploitInfo = self.classify_vulnerability(metasploitName, description, cvss, port)
            if not metasploitInfo:
                return commonOut
            exploit_class = metasploitInfo['class']
            rank_txt = metasploitInfo['rank']
            try:
                rank = CapabilityRank[rank_txt].value
            except:
                rank = CapabilityRank['normal'].value
            templateCapability = self.capabilities[exploit_class]
            if not solution:
                solution = templateCapability.capabilitySolution
            if metasploitInfo:
                commonEntry = {"hostname":hostName,
                               "hostip":hostIP,
                               "hostcpe":hostCPE,
                               "protocol":protocol,
                               "port":port,
                               "type":"exploit",
                               "name":metasploit_module,
                               "class":exploit_class,
                               "rank":rank,
                               "severity":severity,
                               "cvss":cvss,
                               "solution":solution}
                commonOut.append(commonEntry)

        return commonOut

    def check_duplicate(self, commonOut, hostName, protocol = "TCP", port = "0", name = None):
        for item in commonOut:
            if item['hostname'] == hostName:
                if name and item['name'] == name:
                    return True
                elif item['protocol'] == protocol and item['port'] == port:
                    return True

        return False

    def parse_nessus_xml(self):
        logger.info("Converting nessus input file to common format input file")
        tree = ET.parse(self.datafile)
        root = tree.getroot()
        commonOut = []

        for reportHost in root.findall('./Report/ReportHost'):
            hostName = reportHost.attrib['name'].upper()
            hostIP = hostMAC = 'None'
            hostOS = hostVariation = hostArch = '?'

            for tag in reportHost.findall('HostProperties/tag'):
                hostProperty = tag.attrib['name']
                if hostProperty == 'host-ip':
                    hostIP = tag.text
                if 'cpe' in hostProperty:
                    if 'microsoft' in tag.text.lower():
                        hostOS = 'W'
                        if 'windows_xp' in tag.text.lower():
                            hostVariation = 'XP'
                        elif 'windows_7' in tag.text.lower():
                            hostVariation = '7'
                        elif 'windows_vista' in tag.text.lower():
                            hostVariation = 'V'
                        elif 'windows_10' in tag.text.lower():
                            hostVariation = '10'
                    elif 'linux' in tag.text.lower():
                        hostOS = 'L'
                        hostArch = '64'
                        if 'ubuntu' in tag.text.lower():
                            hostVariation = 'UB'
                    if 'x86' in tag.text.lower():
                        hostArch = '32'
                    elif 'x64' in tag.text.lower():
                        hostArch = '64'

                elif hostProperty == 'netbios-name':
                    hostName = tag.text.upper()
                elif hostProperty == 'mac-address':
                    hostMAC = tag.text.upper()
                elif hostProperty == 'hostname' and tag.text != '(none)':
                    hostName = tag.text.upper()

            # If hostname was only in the report as an IP address, attempt to match it with a hostname from hostsDB
            hostName = self.ip_to_hostname(hostName)

            if hostArch == '?':
                for reportItem in reportHost.findall('ReportItem'):
                    for pluginOutput in reportItem.findall('plugin_output'):
                        outputText = pluginOutput.text.lower()
                        if 'x64' in outputText:
                            hostArch = '64'
                        if 'x86' in outputText and hostArch == '?':
                            hostArch = '32'

            hostCPE = "{}/{}/{}".format(hostOS, hostVariation, hostArch)
            logger.debug("Host: {}, CPE: {}".format(hostName, hostCPE))

            for reportItem in reportHost.findall('ReportItem'):
                protocol = reportItem.attrib['protocol'].lower()
                port = reportItem.attrib['port']
                name = reportItem.attrib['svc_name'].lower()
                severity = reportItem.attrib['severity']
                if not port == '0':
                    commonOut = self.build_common_service(hostName, hostIP, hostCPE, protocol, port, name, commonOut)

                # Check if this is an exploit with a metasploit module
                metasploitNameElement = reportItem.find("metasploit_name")

                if metasploitNameElement != None:
                    solution = reportItem.find("solution").text
                    solution = solution.replace('\n',' ')
                    description = reportItem.find("description").text.lower()
                    try: 
                        cvss = reportItem.find("cvss3_vector").text
                    except:
                        try:
                            cvss = reportItem.find("cvss_vector").text
                        except:
                            cvss = ""

                    metasploit_nessus_name = metasploitNameElement.text
                    related_names = MetasploitDB.get_related_names_by_name(metasploit_nessus_name)
                    for metasploit_name in related_names:
                        commonOut = self.build_common_exploit(hostName, hostIP, hostCPE,
                            protocol, port, metasploit_name, description, cvss, severity, solution, commonOut)

        return commonOut


    def parse_nmap_xml(self): 
        logger.info("Converting nmap input file to common format input file")
        tree = ET.parse(self.datafile) 
        root = tree.getroot() 
        commonOut = []
 
        for host in root.findall('./host'):
            hostOS = hostVariation = hostArch = '?'
            hostName = hostMAC = 'None'
            hostIP = host.find('address').attrib['addr']
            for hostname in host.findall('hostnames/hostname'):
                hostName = hostname.attrib['name'].upper()

            for osclass in host.find('os/osmatch/osclass'):
                nmap_cpe = osclass.text.lower()
                if 'microsoft' in nmap_cpe:
                    hostOS = 'W'
                    if 'windows_xp' in nmap_cpe:
                        hostVariation = 'XP'
                    elif 'windows_7' in nmap_cpe:
                        hostVariation = '7'
                    elif 'windows_vista' in nmap_cpe:
                        hostVariation = 'V'
                    elif 'windows_10' in nmap_cpe:
                            hostVariation = '10'
                elif 'linux' in nmap_cpe:
                    hostOS = 'L'
                    hostArch = '64'
                    if 'ubuntu' in nmap_cpe:
                        hostVariation = 'UB'

            hostCPE = "{}/{}/{}".format(hostOS, hostVariation, hostArch)

            for port in host.findall('ports/port'):
                state = port.find('state').attrib['state']
                if not state == 'open':
                    continue
                protocol = port.attrib['protocol'].lower()
                portnumber = port.attrib['portid']
                try:
                    name = port.find('service').attrib['name']
                except:
                    name = ""
                if not portnumber == '0':
                    commonOut = self.build_common_service(hostName, hostIP, hostCPE, protocol, portnumber, name, commonOut)

            for script in host.findall('hostscript/script'):
                output = script.attrib['output'].lstrip().lower()
                if output.startswith('vulnerable'):
                    description = []
                    cve = ""
                    for table in script.findall('table'):
                        if table.attrib['key'].startswith('CVE-'):
                            cve = table.attrib['key']
                            for element in table.findall('elem'):
                                if element.attrib['key'] == 'title':
                                    description.append(element.text)
                            for innerTable in table.findall('table'):
                                if innerTable.attrib['key'] == 'description':
                                    for element in innerTable.findall('elem'):
                                       description.append(element.text)

                    if cve and description:
                        description = ' '.join(description)
                        cvss = ""
                        if 'risk factor: critical' in output: severity = 4
                        elif 'risk factor: high' in output: severity = 3
                        elif 'risk factor: medium' in output: severity = 2
                        elif 'risk factor: low' in output: severity = 1
                        else:
                            logger.warning("NMAP Vulnerability {} has no risk rating, assuming 4".format(cve))
                            severity = 4
                        
                        related_names = MetasploitDB.get_related_names_by_cve(cve)

                        for metasploit_name in related_names:
                            commonOut = self.build_common_exploit(hostName, hostIP, hostCPE,
                                    protocol, portnumber, metasploit_name, description, cvss, severity, "", commonOut)

        return commonOut

    def classify_vulnerability(self, name, description, cvss, port):
        RCE_DESC_MATCH_STRINGS = [r'.*(command|code) execution.*', r'.*arbitrary (code|command).*']
        RCE_DESC_NOMATCH_STRINGS = [r'.*(implant|click).*', r'.*trick user.*']
        RCE_CVSS_MATCH_REGEX= r'.*'
        RCE_CVSS_NOMATCH_REGEX = r'.*(UI:R|AV:L)/.*'

        PE_DESC_MATCH_STRINGS = ['.*(elevation|escalation) of privilege.*', 'privilege escalation']
        PE_DESC_NOMATCH_STRINGS = []
        PE_CVSS_MATCH_REGEX = r'.*AV:L/.*'
        PE_CVSS_NOMATCH_REGEX = r'.*/UI:R/.*'

        METASPLOIT_MODULE_UNDESIRABLES_REGEX = '.*_check|auxiliary/dos.*'

        module = MetasploitDB.get_module_by_name(name)

        # Disregard modules which match the regex.  No check only modules and no denial of service.
        if re.match(METASPLOIT_MODULE_UNDESIRABLES_REGEX, module):
            return None

        metasploitInfo = MetasploitDB.get_info_by_module(module)

        if metasploitInfo:
            metasploitOptions = MetasploitDB.get_options_by_module(module)
            parseThis = "{} {}".format(description.lower(), metasploitInfo.description.lower()).replace('\n','')

            RCE_MATCH = False
            PE_MATCH = False
            if metasploitInfo.module_type == 'exploit' and ('RHOSTS' in metasploitOptions.keys() or 'RHOST' in metasploitOptions.keys()) and 'cmd' not in metasploitInfo.arch:
                for rce_match_string in RCE_DESC_MATCH_STRINGS:
                    if re.match(rce_match_string, parseThis, re.IGNORECASE) and re.match(RCE_CVSS_MATCH_REGEX, cvss) and not re.match(RCE_CVSS_NOMATCH_REGEX, cvss):
                        RCE_MATCH = True
                        for rce_nomatch_string in RCE_DESC_NOMATCH_STRINGS:
                            if re.match(rce_nomatch_string, parseThis, re.IGNORECASE):
                                RCE_MATCH = False

                if RCE_MATCH:
                    if not port or port != '0':
                        logger.debug("Classified '{}' as Remote Code Execution".format(name))
                        return {'rank':metasploitInfo.rank, 'targets':metasploitInfo.targets, 'class':'remote_code_execution'}

            if (metasploitInfo.module_type == 'post' or 'SESSION' in metasploitOptions.keys()) and not ('RHOSTS' in metasploitOptions.keys() or 'RHOST' in metasploitOptions.keys()):
                for pe_match_string in PE_DESC_MATCH_STRINGS:
                    if re.match(pe_match_string, parseThis, re.IGNORECASE) and re.match(PE_CVSS_MATCH_REGEX, cvss) and not re.match(PE_CVSS_NOMATCH_REGEX, cvss):
                        PE_MATCH = True
                        for pe_nomatch_string in PE_DESC_NOMATCH_STRINGS:
                            if re.match(pe_nomatch_string, parseThis, re.IGNORECASE):
                                PE_MATCH = False

                if PE_MATCH:
                    logger.debug("Classified '{}' as Privilege Escalation".format(name))
                    return {'rank':metasploitInfo.rank, 'targets':metasploitInfo.targets, 'class':'privilege_escalation'}

        return None


    def report_capabilities(self):
        for host in self.hostsDB.keys():
            host_exploits = []
            host_services = []
            for capability in self.hostsDB[host]['capabilities']:
                if self.capabilities[capability].capabilityClass == 'exploit':
                    host_exploits.append(capability)
                else:
                    host_services.append(capability)
            if len(host_exploits)+len(host_services) > 0:
                logger.info("Capabilities detected on {}: {} (Exploits: {}, Services: {})".format(host, len(host_exploits)+len(host_services), len(host_exploits), len(host_services)))
                if len(host_exploits) > 0:
                    logger.debug("\tExploits: {}".format(', '.join(host_exploits)))
                if len(host_services) > 0:
                    logger.debug("\tServices: {}".format(', '.join(host_services)))
            elif host != 'ATTACKER':
                logger.warning("Didn't detect ANY capabilities on {}".format(host))

        if len(self.unknown_services.keys()) > 0:
            logger.debug("Unknown Services: {}".format(len(self.unknown_services.keys())))
            for service in self.unknown_services.keys():
                logger.debug("\t{} on hosts {}".format(service, self.unknown_services[service]))

    def fix_metasploit_options(self, metasploitOptions, rport=None):
        actualOptions = []
        foundrport = False
        for option, value in metasploitOptions.items():
            if value is not None and value != '':
                actualOptions.append('{}={}'.format(option.lower(), value))
            elif option.lower() == 'rhost':
                actualOptions.append('rhost=$target_host')
            elif option.lower() == 'lport':
                actualOptions.append('lport=4444')
            elif option.lower() == 'rport':
                foundrport = True
            elif option.lower() == 'rhosts':
                actualOptions.append('rhosts=$target_host')
            elif option.lower() == 'httpusername':
                actualOptions.append('HttpUsername=$username')
            elif option.lower() == 'username':
                actualOptions.append('username=$username')
            elif option.lower() == 'password':
                actualOptions.append('password=$password')
            elif option.lower() == 'httppassword':
                actualOptions.append('HttpPassword=$password')
            elif option.lower() == 'session':
                pass
            else:
                logger.warning("Unsupported metasploit option: {}".format(option))
        if not foundrport and rport != None:
            actualOptions.append('rport={}'.format(rport))
        actualOptions = ' '.join(actualOptions)

        return actualOptions


