#!/usr/bin/python3.7
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Perspecta Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


import sys, os, logging, json, time, argparse
import logging.config

from .organizer import Organizer
from .analyzer import Analyzer
from .planner import Planner
from .config import config
from .database import import_db_from_file
from .metasploitdb import MetasploitDB

__VERSION__ = '0.7.5'

def parse_args():
    parser = argparse.ArgumentParser('a2p2v', description='A2P2V Version {}'.format(__VERSION__))
    parser.add_argument('-v', '--verbose', action='count', default=2, help='Use to display more detailed logging') # Always show error, warning and info
    parser.add_argument('-nx', '--netfile', help='Network Description File (Required for System Mode Planning)', dest='netfile', default=None, required=False)
    parser.add_argument('-f', '--datafile', help='Scan data file to use (Nessus, NMAP, Common)', required=False)

    group = parser.add_mutually_exclusive_group(required=False)
    group.add_argument('-t', '--target', help='Choose a target to run in single host mode.  If omitted all hosts are used')
    group.add_argument('-p', '--plan', default=False, action='store_true', help='Run in system planning mode to generate attack trees based on intial conditions and goal')

    parser.add_argument('-x', '--execute', help='Perform actual execution rather than simulated', default=False, action='store_true')
    parser.add_argument('-s', '--showgraph', help='Display visualizations (Network Representation, Combined Attack Tree, Execution Progress', default=False, action='store_true')
    parser.add_argument('-lh', '--lhost', help='Manually Set LHOST in Metasploit (IP address of attacker) if not correctly detected', dest='lhost', default='172.16.1.200', required=False)
    parser.add_argument('-lt', '--loadtrees', help='Specify a json file with precomputed attack trees to load (skips analysis and planning)', required=False)
    parser.add_argument('-sw', '--switchvisits', help='Set how many times each switch can be visited in an attack tree', required=False, default=1, type=int)
    parser.add_argument('-mh', '--maxhops', help='Set the maximum number of hops allowed per attack tree', required=False, default=5, type=int)
    parser.add_argument('-tn', '--treenum', help='Specify attack tree number to execute if already known', type=int, required=False)
    parser.add_argument('-ms', '--minscore', help='Specify a minimum score for attack trees to display during selection', required=False)
    parser.add_argument('-r', '--reload', default=False, dest="reload_cache", action='store_true', help='Reload the Metasploit cache', required=False)
    parser.add_argument('--postexecutescript', default=None, dest='post_execute_script', required=False, help='Optional: script to execute after each execution')
    parser.add_argument('-db', '--importdb', help='Import an XML formatted file into the database', dest='dbfile', default=None, required=False)
    #parser.add_argument('-bb', '--blackbox', help='Operate in blackbox mode (not currently supported)', default=False, action='store_true')

    return parser.parse_args()

def set_logging(loglevel, filename=None):
    '''Set the loglevel
    The default log level is INFO
    Args:
        loglevel(int): Set the logging level (0=ERROR, 1=WARNING, 2=INFO, 3=DEBUG)
    '''
    LOGFILE_CONF = './logging.yaml'
    global logger

    if os.path.isfile(LOGFILE_CONF):
        # TODO: Load logging configuration from file
        #logging.config.dictConfig(LOGFILE_CONF)
        #logger = logging.getLogger('a2p2v')
        set_logging_manual(loglevel, filename)
    else:
        set_logging_manual(loglevel, filename)

def set_logging_manual(loglevel, filename=None):
    LEVELS = [ 'ERROR', 'WARNING', 'INFO', 'DEBUG' ]
    global logger

    # Configure the logger
    if loglevel > len(LEVELS) - 1:
        loglevel = len(LEVELS) - 1
    elif loglevel < 0:
        loglevel = 0

    # TODO: Checking for logging.conf - if that is present, use that instead

    loglevelname = getattr(logging, LEVELS[loglevel])
    #logging.basicConfig(filename=filename, level=loglevelname)

    logger = logging.getLogger('a2p2v')
    logger.setLevel(loglevelname)

    ch = logging.StreamHandler()
    ch.setLevel(loglevelname)

    # create formatter
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    #root_logger = logging.getLogger()
    #root_logger.setLevel(logging.DEBUG)
    #root_logger.addHandler(ch)

    logger.debug('Log level set to {}'.format(loglevelname))

def main():
    args = parse_args()
    treeNumber = None
    target = None

    set_logging(args.verbose)

    # Clean the cache
    if args.reload_cache:
        MetasploitDB.clean()
        
    if args.minscore:
        minimum_score = args.minscore
    else:
        minimum_score = False


    if args.loadtrees:
        try:
            with open(args.loadtrees) as f:
                attack_trees = json.load(f)
        except Exception as e:
            logger.error("Unable to load trees from file {} ({})".format(args.loadtrees, str(e)))
            return

        if not 'goals' in attack_trees[0].keys() and args.plan:
            logger.error("Planning specified, but loaded trees are for single host mode.  Cannot continue.")
            return

        if 'goals' in attack_trees[0].keys() and not args.plan:
            logger.error("Planning not specified, but loaded trees are for system planning mode.  Cannot continue.")
            return

        planner = type('obj', (object,), {'attack_trees' : attack_trees})
    else:
        if args.dbfile != None:
            import_db_from_file(args.dbfile)
            return

        analyzer = Analyzer(args.execute, args.plan, datafile=args.datafile, netfile=args.netfile)
        if not analyzer.valid:
            logger.error("Invalid analyzer config")
            return

        analyzer_status = analyzer.run()
        if not analyzer_status:
            logger.error("Analysis did not complete successfully")
            return
        else:
            logger.info("Analysis completed successfully")

        if args.target:
            target = analyzer.ip_to_hostname(args.target)
            if not target in analyzer.hostsDB.keys():
                logger.error("Target host {} unknown".format(target))
                return
        else:
            target = None

        planner = Planner(analyzer.capabilities, analyzer.hostsDB, analyzer.networkGraph, args.switchvisits, args.maxhops)

        if args.plan:
            logger.info("Planning will be performed")
            planner.run()
            logger.info("Planning complete")
        else:
            logger.info("Planning will not be performed")
            planner.find_all_vulns(target)

        attack_trees = planner.attack_trees

    if args.plan:
        mode = 'system'
    #elif args.blackbox:
    #    mode = 'black'
    else:
        mode = 'single'

    organizer = Organizer(planner, mode, minimum_score, visualizations=args.showgraph, execute=args.execute, post_execute_script=args.post_execute_script, lhost=args.lhost)

    if not os.path.exists('reports'):
        os.makedirs('reports')

    filename_timestamp = organizer.get_timestamp(2)

    if not args.loadtrees and attack_trees:
        attack_trees_filename = "reports/attack_trees_{}.json".format(filename_timestamp)
        with open(attack_trees_filename, 'w') as f_attack_trees:
            f_attack_trees.write(json.dumps(attack_trees, indent=2))
        logger.info("Attack trees written to: {}".format(attack_trees_filename))

    # If a target is specified, operate in single-host mode for the target host only
    if target != None:
        result = organizer.launch(args.treenum, targets=[target.upper()])
    # If a target is not specified, and planning is not selected, operate in single-host mode for all hosts
    elif not args.plan:
        result = organizer.launch(args.treenum, targets=get_hosts_from_trees(attack_trees))
    # If planning is selected operate in system planning mode for all hosts (not yet fully supported)
    elif args.plan:
        result = organizer.launch(args.treenum)

    if result:
        report_filename = organizer.create_report(args.plan)

    logger.info("Exiting")

def get_hosts_from_trees(tree_list):
    hosts = set()
   
    for attack_tree in tree_list:
        hop_list = attack_tree['hops']
        [ hosts.add(hop['node']) for hop in hop_list ]

    return hosts


if __name__ == "__main__":
    main()
