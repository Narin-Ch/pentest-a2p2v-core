#!/usr/bin/python3
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Perspecta Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


import ast
import logging, copy, sys, re
from enum import IntEnum
from .config import config
from .config import get_config_filename

ip_prefix_pattern = re.compile(r'(\d+.\d+.\d+).(\d+)')

__VERSION__ = '0.3'

# Used to assign numeric values to compare access levels
class AccessClass(IntEnum):
    none = 0
    web = 1
    shell = 2
    desktop = 3
    metasploit = 4

# Used to assign numeric values to compare user roles
class UserRole(IntEnum):
    none = 0
    user = 1
    admin = 2

# Used to designate which iteration find_all_paths algorithm is in
class FindMode(IntEnum):
    goal = 0
    access = 1

logger = logging.getLogger(__name__)

##########################################
# Holds information about the state of the current attack tree
class State(object):
    def __init__(self, currentHost=None, currentStatus=None):
        if currentStatus == None:               
            currentStatus = set()
        
        self.current_host = currentHost         # Stores the host access is on currently
        self.current_status = currentStatus     # Stores a set of status strings (capability names or items set by post conditions)
        self.initial_host = None                # Stores the initial host (generally the attacker)
        self.current_role = UserRole.none       # Stores the current user role on the current host (See UserRole)
        self.current_access = AccessClass.none  # Stores the current access type on the current host (See AccessClass)
        self.temp = {}                          # Dictionary to hold parameters and values to be passed from precondition to postcondition
        self.credentials = []                   # List of Credential instances with credentials held in current state

    # Adds a status value if it doesn't already exist in the list
    def add_status(self, status):
        logger.debug("Adding status: {} to current status".format(status))
        self.current_status.add(status)

    # Resets current status only
    def clear_current_status(self):
        logger.debug("Clearing current status")
        self.current_status = set()

    # Resets current host only
    def clear_current_host(self):
        logger.debug("Clearing current host")
        self.current_host = None

    def add_credential(self, credentialHost, credentialUserRole, credentialUsername=None, credentialPassword=None, credentialHash=None):
        '''
        Arguments:
            credentialHost(str): the host name or IP address this credential is for (required)
            credentialUserRole(str): the user role associated with the credential (required)
            credentialUsername(str): the username portion of the credential (optional)
            credentialPassword(str): the password portion of the credential (optional)
            credentialHash(str): a hash/token which represents a username/password (optional)
        '''

        # If a credential already exists for the specified host with the specified role, just return
        if self.get_credential(credentialHost, credentialUserRole):
            return
        newCredential = Credential(credentialHost, credentialUserRole, credentialUsername, credentialPassword, credentialHash)
        self.credentials.append(newCredential)

    def get_credential(self, credentialHost, minUserRole):
        '''
        Arguments:
            credentialHost(str): hostname
            minUserRole(str): minimum role to find ( 'none', 'user', or 'admin')
        Returns:
            dict: containing 'username', 'password' and 'role' or None
        '''
        result = None
        for credential in self.credentials:
            if credential.host == credentialHost and UserRole[credential.role] >= UserRole[minUserRole]:
                if credential.role == 'admin':
                    logger.debug("Found an admin role credential")
                    result = {"username": credential.username, "password": credential.password, "role": credential.role}
                    break
                else:
                    logger.debug("Found a non-admin role credential")
                    result = {"username": credential.username, "password": credential.password, "role": credential.role}
        return result

    def __str__(self):
        return 'state: status={}, initial_host={}, current_host={}, current_role={}, current_access={}, credentials={}'.format(self.current_status,
                self.initial_host, self.current_host, self.current_role, self.current_access, self.credentials)

    def __repr__(self):
        return self.__str__()

class Credential(object):
    def __init__(self, credentialHost, credentialUserRole, credentialUsername, credentialPassword, credentialHash):
        '''
        Constructor:
            credentialHost(str): the host name
            credentialUserRole(str): value: none, user, admin
            credentialUsername(str): the name of the user
            credentialPassword(str): the user's password
            credentialHash(str): a hash, or token, which represents a username/password
        '''
        self.host = credentialHost
        self.role = credentialUserRole
        self.username = credentialUsername
        self.password = credentialPassword
        self.hash = credentialHash

    def __str__(self):
        return 'Credential({}, {}, {}, {}, {})'.format(self.host, self.role, self.username, self.password, self.hash)

    def __repr__(self):
        return self.__str__()


class Planner:
    ''' Constructor:  set up configuration and logger
    '''
    def __init__(self, capabilities, hostsDB, networkGraph, switchvisits=1, maxHops=5):
        self.capabilities = capabilities
        self.networkGraph = networkGraph
        self.hostsDB = hostsDB
        self.switchVisits = switchvisits
        self.maxHops = maxHops
        self.duplicates = 0

        self.goals = []
        self.sensitives = []
        self.state = State()
        self.attack_trees = []
        self.get_sensitive_states()
        self.score_weights = ast.literal_eval(config.get('PLANNING', 'score_weights'))

    def hostname_to_ips(self,target,network=None):
        '''
        Arguments:
            target(str): hostname
            network(str): optional: network component (e.g. "192.168.20")
        Returns:
            list(str): list of IP addresses
        '''
        ips = []
        if target in self.hostsDB.keys():
           interfaces = self.hostsDB[target]['interfaces']
           for interface in interfaces:
               if not network:
                   ips.append(interface[0])
               elif network and interface[0].startswith(network):
                   ips.append(interface[0])
        
        return ips

    def ip_to_hostname(self, target):
        '''Given an IP, look up the hostname.  If a hostname is given, simply return the same hostname.
        Arguments:
            target(str): ip address (or hostname)
        Returns:
            str: the corresponding hostname
        '''
        if not target in self.hostsDB.keys():
            for host, hostDetails in self.hostsDB.items():
                if target in [interface[0] for interface in hostDetails['interfaces']]:
                    logger.debug("IP address {} resolved to host {}".format(target, host))
                    target = host

        return target

    def hostMatch(self, host1, host2):
        ''' Match host1 against host2 with wildcard match if either is *.  Also matches if either host is an IP on the other.
        Arguments:
            host1(str): first host to match against (may be hostname, IP address or wildcard [*])
            host2(str): second host to match against (may be hostname, IP address or wildcarde [*])
        Returns:
            bool: If a match has been made
        '''
        if host1 == host2 or host1 in self.hostname_to_ips(host2) or host2 in self.hostname_to_ips(host1) or host1 == '*' or host2 == '*':
            return True

        return False

    def ip_from_nic_node(self, node):
        ''' Get the IP address of a nic node
        Arguments:
            node(str): the node (assumed to be a NIC) to get the IP address for
        Returns:
            str: IP address of the nic
        '''
        ipAddress = self.networkGraph.nodes[node]['nodeID']

        if not ipAddress:
            logger.error("Can't resolve interface {}".format(node))
        return ipAddress

    def is_derived(self, capabilityID):
        ''' Test if a capability is a derived capability by checking if there are any 'capability' type preconditions
        Arguments:
            capabilityID(str): the ID of the capability to test
        Returns:
            bool: If the capability is derived or not
        '''

        if capabilityID in self.capabilities.keys():
            for precondition in self.capabilities[capabilityID].preconditions:
                if precondition['type'] == 'capability':
                    return True
        return False

    def get_parent_capabilityID(self, capabilityID):
        ''' Returns the parent capabilityID for a derived capability
        Arguments:
            capabilityID(str): the ID of the derived capability
        Returns:
            capabilityID(str): the parent capability ID
        '''

        if self.is_derived(capabilityID):
            parentCapabilityID =  '.'.join(capabilityID.split('.')[:-1])
            return parentCapabilityID

        return None

    def is_passive(self,node):
        ''' Test if a node is passive
        Arguments:
            node(str): the node to test
        Returns:
            bool: If the node is passive or not
        '''
        if self.networkGraph.nodes[node]['nodePassive']:
            return True
        return False

    def is_switch(self, node):
        ''' Test if a node is a switch
        Arguments:
            node(str): the node to test
        Returns:
            bool: If the node is a switch or not
        '''
        if self.networkGraph.nodes[node]['nodeType'] == 'switch':
            return True
        return False

    def is_nic(self, node):
        ''' Test if a node is a NIC
        Arguments:
            node(str): the node to test
        Returns:
            bool: If the node is a NIC or not
        '''
        if self.networkGraph.nodes[node]['nodeType'] == 'interface':
            return True
        return False

    def set_initial_state(self):
        ''' Sets planner initial state from configuration file
        Arguments: None
        Returns:   None
        '''
        logger.debug("Setting Initial State")
        if not self.state:
            self.state = State()

        for state_item in config.options('INITIAL CONDITIONS'):
            newState = ast.literal_eval(config.get('INITIAL CONDITIONS', state_item))
            if newState['type'].lower() == 'state':
                if newState['key'] == "initial_host":
                    initial_host = newState['value'].upper()
                    self.state.initial_host = initial_host.upper()
                    self.state.current_host = initial_host.upper()
                if newState['key'] == "current_role":
                    self.state.current_role = UserRole[newState['value']]
                if newState['key'] == "current_access":
                    self.state.current_access = AccessClass[newState['value']]
            elif newState['type'].lower() == 'credential':
                if not 'host' in newState.keys() or not 'role' in newState.keys():
                    logger.error("Initial state: Invalid credential. Missing required host or role information")
                    return
                credentialHost = newState['host'].upper()
                credentialUserRole = newState['role']
                credentialUsername = None
                credentialPassword = None
                credentialHash = None
                if 'username' in newState.keys():
                    credentialUsername = newState['username'].lower()
                if 'password' in newState.keys():
                    credentialPassword = newState['password']
                if 'hash' in newState.keys():
                    credentialHash = newState['hash']
                if not credentialHash and not credentialUsername:
                    logger.error("Initial state: Invalid credential.  Must include either hash or username/password")
                    return
                self.state.add_credential(credentialHost, credentialUserRole, credentialUsername, credentialPassword)

    def test_preconditions(self, targetHost, capability):
        ''' Test if preconditions are met for a capability on a host (assumes current host is neighbor of target host)
        Arguments:
            targetHost(str): the host to check capability preconditions on
            capability(Capability): the capability to check
        Returns:
            bool: If the preconditions can be met or not
        '''

        # TODO: Do a sanity check to ensure targetHost is a neighbor of self.state.current_host
        # The below doesn't work because targetHost and self.state.current_host may not be the names of the nodes in the graph
        #if not targetHost in self.networkGraph[targetHost]:
        #    logger.error("Neighbors for {} are {}".format(targetHost, self.networkGraph[self.state.current_host]))

        logger.debug('test_preconditions() Entered: targetHost={}, capability={}'.format(targetHost, capability.capabilityID))

        currentAccessLevel = self.state.current_access
        currentUserRole = self.state.current_role
        currentStatus = self.state.current_status

        numRequired = len(capability.preconditions)
        for precondition in capability.preconditions:
            conditionMet = False
            pcHost = precondition['host']
            pcType = precondition['type']
            pcKey = precondition['key']
            pcValue = precondition['value']
            if pcType == 'service':
                conditionMet = True
            elif pcType == 'state':
                if pcKey == 'current_access':
                    requiredAccessLevel = AccessClass[pcValue]
                    logger.debug("Access level on Current host ({}): {}, Required Access level: {}, target host: {}".format(self.state.current_host, currentAccessLevel, requiredAccessLevel, targetHost))
                    if pcHost == '$current_host' or (pcHost == '$target_host' and targetHost == self.state.current_host):
                        if currentAccessLevel and currentAccessLevel >= requiredAccessLevel:
                            logger.debug("Current Access requirement met")
                            conditionMet = True
                        else:
                            logger.debug("Current Access requirement not met")
                elif pcKey == 'current_role':
                    requiredUserRole = UserRole[pcValue]
                    logger.debug("Current User Role: {}, Required User Role: {}".format(currentUserRole, requiredUserRole))
                    if currentUserRole >= requiredUserRole:
                        conditionMet = True
                elif pcKey == 'current_status':
                    logger.debug("Current Status: {}, Required Status: {}".format(currentStatus, pcValue))
                    if pcValue in currentStatus:
                        logger.debug("Current Status requirement met")
                        conditionMet = True
                    else:
                        logger.debug("Current Status requirement not met")
            elif pcType == 'capability':
                logger.debug("Required Capability: {}".format(pcValue))
                for icapability in self.capabilities.keys():
                    if self.capabilities[icapability].capabilitySubClass == pcValue:
                        conditionMet = self.test_preconditions(targetHost, self.capabilities[icapability])
            elif pcType == 'credential':
                requiredUserRole = pcValue
                logger.debug("Required Credential for User Role: {}".format(requiredUserRole))
                credential = self.state.get_credential(targetHost, requiredUserRole)
                if credential:
                    logger.debug("Credential requirement met")
                    conditionMet = True
                    self.state.temp['role'] = credential['role']
                else:
                    for action in capability.actions:
                        if '$$' in action['value']:
                            logger.warning("Allowing a precondition to pass with a default credential based on action: {}".format(action['value']))
                            conditionMet = True
                    if not conditionMet:
                        logger.debug("Credential requirement not met")

            if conditionMet == True:
                numRequired -= 1
                       
        if numRequired == 0:
            logger.debug("We've satisfied all the pre-conditions for this capability!")
            return True

        logger.debug("We could not satisfy all the pre-conditions for this capability ({} left)".format(numRequired))
        return False

    def find_all_vulns(self, host=None):
        ''' Find all vulnerabilities for a given host, or for all hosts if none is specified
        Arguments:
            host(str): the host to find vulnerabilities on (optional)
        Returns: None
        '''
        if host and not host == 'None':
            self.find_all_host_vulns(host.upper())
        else:
            for host in self.hostsDB.keys():
                self.find_all_host_vulns(host)

        self.attack_trees = sorted(self.attack_trees, key = lambda i: i['score']['combined'], reverse=True)

    def get_capability_protoport(self, capabilityID):
        protoport = "N/A"
        while self.is_derived(capabilityID):
            capabilityID = self.get_parent_capabilityID(capabilityID)
        for condition in self.capabilities[capabilityID].preconditions:
            if condition['type'] == 'service':
                protoport = condition['value']

        return protoport.upper()

    # Used in single host mode
    def find_all_host_vulns(self, host):
        ''' Find all vulnerabilities for a given host
        Arguments:
            host(str): the host to find vulnerabilities on
        Sets:
            self.attack_trees(): JSON formatted attack trees
        Returns: None
        '''
        for hostCapability in self.hostsDB[host]['capabilities']:
            fullCapability = self.capabilities[hostCapability]
            protocolPort = self.get_capability_protoport(hostCapability)
            capability_label = "{} ({})".format(fullCapability.capabilityTitle.upper(), protocolPort)
            host_tree = {'hops':[],'score':{'severity':0,'services':0,'exploits':0}}
            capability_actions = self.get_actions(host, hostCapability)
            if capability_actions:
                self.state.clear_current_status()
                self.update_status(hostCapability)
                sensitivity = self.check_sensitive()
                newNode = {"node":host, "options":[{"capability":capability_label, "class":fullCapability.capabilityClass, "solution":fullCapability.capabilitySolution, "severity":fullCapability.capabilitySeverity, "rank":fullCapability.capabilityRank, "actions":capability_actions}]}
                if fullCapability.capabilityCVEs:
                    newNode['options'][0]['cves'] = fullCapability.capabilityCVEs
                if sensitivity:
                    newNode['options'][0]['sensitivity'] = sensitivity

                host_tree['hops'].append(newNode)

                self.add_attack_tree(host_tree)

        return

    # Computes combined score for attack trees given certain criteria about the path.  Utilizes global variables for weights.
    def combined_score(self, attackTree):
        return round(10 + self.score_weights['NUM_EXPLOITS'] * attackTree['score']['exploits'] +
                          self.score_weights['LENGTH'] * attackTree['score']['len'] +
                          self.score_weights['SEVERITY'] * attackTree['score']['severity'] +
                          self.score_weights['NUM_SERVICES'] * attackTree['score']['services'], 2)

    def add_attack_tree(self, attackTree):
        ''' Adds a new attack tree to the list of attack trees and checks to ensure no duplicates
        Arguments:
            attackTree(dict): a successful attack tree to add to the global list
        Sets:
            self.attack_trees(): JSON formatted attack trees
        Returns: None
        '''

        #TODO: Can't we eliminate duplicates here by simply comparing hops?

        thisAttackTree = copy.deepcopy(attackTree)

        thisAttackTree['score']['len'] = len(attackTree['hops'])
        severity = exploits = services = 0
        for hop_num, hop in enumerate(attackTree['hops']):
            thisAttackTree['hops'][hop_num]['options'] = sorted(hop['options'], key = lambda i: i['rank'], reverse=True)
            for option in hop['options']:
                severity += option['severity']
                if option['class'] == 'service':
                    services += 1
                if option['class'] == 'exploit':
                    exploits += 1
            severity = round(severity / len(hop['options']), 2)
            services = round(services / len(hop['options']), 2)
            exploits = round(exploits / len(hop['options']), 2)

        thisAttackTree['score']['severity'] = severity
        thisAttackTree['score']['services'] = services
        thisAttackTree['score']['exploits'] = exploits
        thisAttackTree['score']['combined'] = self.combined_score(thisAttackTree)

        if 'goals' in attackTree.keys():
            thisAttackTree['goals'] = list(attackTree['goals'])

        if self.is_duplicate_tree(thisAttackTree):
            logger.debug("Duplicate tree: {}->{}".format(thisAttackTree['hops'][0]['node'],thisAttackTree['hops'][-1]['node']))
            return

        logger.debug("Adding attack tree: {}->{}".format(thisAttackTree['hops'][0]['node'],thisAttackTree['hops'][-1]['node']))
        self.attack_trees.append(thisAttackTree)

    def is_duplicate_tree(self, tree):
        for attack_tree in self.attack_trees:
            if tree == attack_tree:
                logger.debug("Duplicate tree detected")
                #logger.info("Tree to be added: {}".format(tree['hops']))
                #logger.info("Existing Tree: {}".format(attack_tree['hops']))
                self.duplicates += 1
                return True

        return False

    def find_all_paths(self, tree=None, start=None, path=None, last_interface_ip=None):
        '''Find all paths given a start, graph and goal.  Used in system planning mode
        Args:
            tree(dict): Current potential attack tree
            start(str): hostname of the node to start with for this iteration
            path(list): path built up (includes all nodes including passive)
            last_interface_ip(str): The IP address of the last interface which was passed through in the path
        Sets:
            self.attack_trees(): JSON formatted attack trees
        Returns: None
        '''

        if start is None:
            start = self.state.initial_host
        if tree is None:
            tree = {"hops":[],"score":{}, "goals":set()}
        if path is None:
            path = []

        if len(tree['hops']) > self.maxHops:
            return

        myTree = copy.deepcopy(tree)
        preNodeState = copy.deepcopy(self.state)
        logger.debug('Entered: find_all_paths(tree={}, state={}, current node={}, path={})'.format(tree, self.state, start, path))
        for node in self.networkGraph[start]:
            logger.debug("Trying node: {}".format(node))
            actions = {'actions':[]}
            if node not in path or ( self.is_nic(node) and path.count(node) < self.switchVisits) or ( self.is_switch(node) and path.count(node) < self.switchVisits ):
            #if node not in path or ( self.is_switch(node) and path.count(node) < self.switchVisits ):
                if node == self.state.initial_host or self.is_passive(node):
                    logger.debug('Adding node {} to current path'.format(node))
                    if self.is_nic(node):
                        last_interface_ip = self.ip_from_nic_node(node)
                else:
                    targetHost = self.ip_to_hostname(self.networkGraph.nodes[node]['nodeID'])

                    targetHostGoalID = self.check_target_host_goal(targetHost)
                    if targetHostGoalID:
                        logger.debug("Met target host goal: {}".format(targetHostGoalID))
                        myTree['goals'].add(targetHostGoalID)
                        self.add_attack_tree(myTree)
                        return # Unwind

                    goalHopOptions = []
                    accessHopOptions = []
                    newHop = {"node":node, "options":[]}
                    mode = FindMode.goal

                    while True:
                        # Iterate twice.  Once looking for goals, once looking for access.
                        capabilityIndex = 0
                        while capabilityIndex < len(self.hostsDB[targetHost]['capabilities']):
                            logger.debug("Capability index {} on {}".format(capabilityIndex, targetHost))
                            self.state.clear_current_status()
                            self.state.clear_current_host()
                            hostCapabilityName = self.hostsDB[targetHost]['capabilities'][capabilityIndex]

                            fullCapability = self.capabilities[hostCapabilityName]

                            # Check if capability preconditions are met
                            logger.debug("Trying capability {} on {}".format(hostCapabilityName, targetHost))
                            if self.test_preconditions(targetHost, fullCapability):
                                logger.debug('Capability can be used!')

                                # Store state before trying a capability
                                preCapabilityState = copy.deepcopy(self.state)

                                # Set postconditions in state
                                self.set_post_conditions(targetHost, hostCapabilityName)

                                stateChange = self.check_state_change(preCapabilityState)

                                logger.debug("Mode: {}, StateChange: {}".format(mode, stateChange))

                                if mode == FindMode.goal and stateChange['goal'] or mode == FindMode.access and stateChange['target_access']:
                                    logger.debug("We have progress with this capability: {}".format(stateChange))
                                    actions = self.get_actions(node, hostCapabilityName, hostIP=last_interface_ip)
                                    protocolPort = self.get_capability_protoport(hostCapabilityName)
                                    capability_label = "{} ({})".format(fullCapability.capabilityTitle.upper(), protocolPort)

                                    newOption = {"capability":capability_label, 
                                                 "class":fullCapability.capabilityClass, 
                                                 "severity":fullCapability.capabilitySeverity, 
                                                 "rank":fullCapability.capabilityRank, 
                                                 "cves":fullCapability.capabilityCVEs, 
                                                 "solution":fullCapability.capabilitySolution, 
                                                 "actions":actions}

                                    if stateChange["sensitive"]:
                                        newOption["sensitivity"] = stateChange["sensitive"]

                                    if mode == FindMode.goal  and stateChange['goal']:
                                        logger.debug("Goal met with capability {} on {}".format(hostCapabilityName, targetHost))
                                        goalHopOptions.append(newOption)
                                        myTree['goals'].add(stateChange['goal'])

                                    elif mode == FindMode.access and stateChange['target_access']:
                                        logger.debug("Target access gained with capability {} on {}".format(hostCapabilityName, targetHost))
                                        accessHopOptions.append(newOption)

                                elif mode == FindMode.access and stateChange['role_esc'] or stateChange['access_esc'] or stateChange['new_cred']:
                                    # Not currently handled
                                    pass

                            logger.debug("Incrementing capability index")
                            capabilityIndex += 1

                        # End Capability Loop: All capabilities have been tried
                        if mode == FindMode.goal:
                            logger.debug("Evaluate 'goal' mode options")
                            if len(goalHopOptions) > 0:
                                logger.debug("We have goals in phase 0!: {}".format(goalHopOptions))
                                newHop['options'] = goalHopOptions
                                if not newHop in myTree['hops']:
                                    myTree['hops'].append(newHop)
                                self.add_attack_tree(myTree)
                                # If the goal reached is host specific, stop exploring this path and return
                                for goal in myTree['goals']:
                                    if self.is_goal_host_specific(goal):
                                        # Restore state to that before this node was accessed
                                        self.state = copy.deepcopy(preNodeState)
                                        return
                            logger.debug("Setting mode to 'Access'")
                            mode = FindMode.access
                            continue
                        elif mode == FindMode.access:
                            if len(accessHopOptions) > 0:
                                logger.debug("We have access in phase 1!: {}".format(accessHopOptions))
                                newHop['options'] = accessHopOptions
                                # TODO: Investigate why duplicates are occurring
                                if not newHop in myTree['hops']:
                                    myTree['hops'].append(newHop)
                                else:
                                    logger.debug("Duplicate hop: {}".format(newHop))
                                    #logger.info("Path: {}".format(path))
                                break
                            else:
                                logger.debug("Mode is 1 and no access on this host")
                                # Restore state to that before this node was accessed
                                self.state = copy.deepcopy(preNodeState)
                                return

                    #End of double loop through capabilities

                path = path + [node]
                self.find_all_paths(myTree, node, path, last_interface_ip)

            logger.debug("Node {} is already in path, or is a switch that's been limited in visits".format(node))

        logger.debug("No more neighbor nodes for this branch or switch visit limit hit")
        # Restore state to that before this node was accessed
        self.state = copy.deepcopy(preNodeState)
        return # No more neighbor nodes in this branch

    def check_target_access(self, preState):
        if preState.current_host != self.state.current_host:
            return True
        return False

    def check_role_esc(self, preState):
        if preState.current_role < self.state.current_role:
            return True
        return False

    def check_access_esc(self, preState):
        if preState.current_access < self.state.current_access:
            return True
        return False

    def check_new_credential(self, preState):
        if len(preState.credentials) > len(self.state.credentials):
            return True
        return False

    def check_state_change(self, preState):
        ''' Compares post state vs pre state to see if progress has been made and/or any goals have been met
        Arguments:
            preState(State): State prior to capability being used
        Returns:
            result(dict): A dictionary with result information
                      target_access (bool): Indicates whether access was gained to the target
                      role_esc (bool)       Indicates role elevation
                      access_esc (bool)     Indicates access elevation
                      new_cred (bool)       Indicates a new credential was added
                      goal(str)             Name of a goal if met
                      sensitive(dict)       a dictionary with information regarding sensitive host or state reached
        '''
        logger.debug("Checking to see if state has been positively changed")
        logger.debug("preState: {}".format(preState))
        logger.debug("postState: {}".format(self.state))

        result = {}
        result["target_access"] = self.check_target_access(preState)
        result["role_esc"] = self.check_role_esc(preState)
        result["access_esc"] = self.check_access_esc(preState)
        result["new_cred"] = self.check_new_credential(preState)
        result["sensitive"] = self.check_sensitive()
        result["goal"] = self.check_goal_reached()

        return result

    def check_current_host_goal(self, goalHost):
        if self.hostMatch(goalHost, self.state.current_host):
            logger.debug("Reached Current Host Goal: {}".format(goalHost))
            return True
        return False

    def check_target_host_goal(self, targetHost):
        for goal in self.goals:
            if goal['key'] == 'target_host' and self.hostMatch(targetHost, goal['value']):
                logger.debug("Reached Target Host Goal on: {}".format(targetHost))
                return goal['id']
        return None

    def check_current_status_goal(self, goalStatus, goalHost):
        if goalStatus in self.state.current_status and self.hostMatch(goalHost, self.state.current_host):
            logger.debug("Reached Current Status Goal on: {}".format(goalStatus))
            return True
        return False

    def check_current_access_goal(self, goalAccess, goalHost):
        if AccessClass[goalAccess] == self.state.current_access and self.hostMatch(goalHost, self.state.current_host):
            logger.debug("Reached Current Access Goal on: {}".format(goalHost))
            return True
        return False

    def check_current_role_goal(self, goalRole, goalHost):
        if UserRole[goalRole] == self.state.current_role and self.hostMatch(goalHost, self.state.current_host):
            logger.debug("Reached Current Role Goal on: {}".format(goalHost))
            return True
        return False

    def is_goal_host_specific(self, goalID):
        for goal in self.goals:
            if goalID == goal['id']:
                if goal['key'] == 'current_host' or 'host' in goal.keys():
                    return True

        return False

    def check_goal_reached(self):
        ''' Checks current state to see if a goals have been reached
        Returns:
	    (list): A list containing the goalIDs of any goals met
        '''
        logger.debug("Checking current state against goal states")
        for goal in self.goals:
            goalID = goal['id']
            goalKey = goal['key']
            goalValue = goal['value']
            try:
                goalHost = goal['host']
            except:
                goalHost = '*'
            if goalKey == 'current_host' and self.check_current_host_goal(goalValue) or \
            goalKey == 'current_status' and self.check_current_status_goal(goalValue, goalHost) or \
            goalKey == 'current_access' and self.check_current_access_goal(goalValue, goalHost) or \
            goalKey == 'current_role' and self.check_current_role_goal(goalValue, goalHost):
                logger.debug("Met Goal {}!".format(goalID))
                return goalID

        return None

    def check_sensitive(self):
        ''' Checks given state to see if any sensitive states have been reached
        Arguments:
            state(State): State to check
        Returns:
	    (dict): 2 values, first being 'type' of sensitive state (host or status) second being 'value' for which host or status applied
        '''
        logger.debug("Checking sensitive state")
        sensitive = {}
        logger.debug("Current Status in check_sensitive: {}".format(self.state.current_status))
        for sensitiveItem in self.sensitives:
            sensitiveKey = sensitiveItem['key']
            sensitiveValue = sensitiveItem['value']
            if sensitiveKey == 'current_host' and self.state.current_host and self.hostMatch(sensitiveValue.upper(), self.state.current_host):
                logger.debug("Reached Sensitive Host: {}".format(sensitiveValue))
                sensitive["type"] = "host"
                sensitive["value"] = sensitiveValue
            elif sensitiveKey == 'current_status' and sensitiveValue in self.state.current_status:
                logger.debug("Reached Sensitive State: {}".format(sensitiveValue))
                sensitive["type"] = "status"
                sensitive["value"] = sensitiveValue

        return sensitive

    def get_credential_value(self, host: str, parameter: str, min_role: str = 'user') -> str:
        '''Obtain a parameter from the credentials
        Arguments:
            host (str): hostname
            parameter (str): parameter, e.g. 'username', 'password'
            min_role (str): minimum role the user should have, default: 'user'
        Returns:
            str: the value of the parameter (or if it can not be determined: $parameter)
        '''
        value = f'${parameter}'

        if self.state:
            credential = self.state.get_credential(host, min_role)
        
            if credential:
                value = credential.get(parameter, f'${parameter}')

        return value

    def get_actions(self, host, capabilityID, hostIP=None):
        ''' Get the actions for a particular capability, filling any variables
        Arguments:
            host(str): 
            capabilityID(str): 
            ipAddress(str):
        Returns:
	    (list): List of action dictionaries
        '''
        capability = self.capabilities[capabilityID]

        if not hostIP:
            hostIP = list(self.hostsDB[host]['interfaces'])[0][0]

        if capability.capabilityClass == 'service':
            logger.debug("Getting actions for service capability: {} on host: {} with IP Address: {}".format(capability.capabilitySubClass, host, hostIP))
        else:
            logger.debug("Getting actions for exploit capability: {}:{} on host: {} with IP Address: {}".format(capability.capabilitySubClass, capability.capabilityCVEs, host, hostIP))
        finalActions = []
        if capability.actions:
            logger.debug("Found actions for capability: {}".format(capability.actions))
            actions = self.resolve_capability_action(capability, {}, [])

            logger.debug("Resolved actions for capability: {}".format(actions))
            for action in actions:
                newAction = copy.deepcopy(action)
                if '$target_host' in newAction['value']:
                    newAction['value'] = newAction['value'].replace('$target_host', hostIP)
                    logger.debug("Replacing $target_host with {}".format(hostIP))
                if '$username' in newAction['value']:
                    username = self.get_credential_value(host, 'username')
                    newAction['value'] = newAction['value'].replace('$username', username)
                    logger.debug("Replacing $username with {}".format(username))
                if '$password' in newAction['value']:
                    password = self.get_credential_value(host, 'password')
                    newAction['value'] = newAction['value'].replace('$password', password)
                    logger.debug("Replacing $password with {}".format(password))
                if '$hash' in newAction['value']:
                    ahash = self.state.get_credential_value(host, 'hash')
                    newAction['value'] = newAction['value'].replace('$hash', ahash)
                    logger.debug("Replacing $hash with {}".format(ahash))

                if '$' in newAction['value'] and not '$session' in newAction['value']:
                    logger.debug("The capability has an action with an undefined parameter.  It will be ignored")
                    logger.debug('newAction = %s', newAction)
                    return []

                if action['type'] == 'metasploit' and capability.capabilitySubClass == 'remote_code_execution':
                    payload = self.get_payload(host)
                    newAction['value'] = "{} payload={}".format(newAction['value'], payload)

                finalActions.append(newAction)

        return finalActions

    def get_payload(self, host):
        try:
            hostCPE = self.hostsDB[host].get('cpe', '?/?/?')
        except:
            logger.error("Host doesn't have CPE: {}".format(host))
            logger.error(self.hostsDB)
        hostOS, hostVariation, hostArch = hostCPE.split('/')

        # Set empty payload
        payload = ''
        if hostOS == 'W':
            if hostArch == '32':
                payload = config.get('METASPLOIT', 'w32payload', fallback='windows/meterpreter/bind_tcp')
            if hostArch == '64':
                payload = config.get('METASPLOIT', 'w64payload', fallback='windows/meterpreter/bind_tcp')
        elif hostOS == 'L':
            if hostArch == '32':
                payload = config.get('METASPLOIT', 'l32payload', fallback='linux/x86/meterpreter/bind_tcp')
            if hostArch == '64':
                payload = config.get('METASPLOIT', 'l64payload', fallback='linux/x64/meterpreter/bind_tcp')
        return payload

    @classmethod
    def get_parameter_dict(cls, action_value):
        '''Given a string of metasploit parameters, parse and return a dictionary of values.
        Arguments:
            action_value(str): metasploit parameters in the format "name1=value1 name2=value2 ..."
            For example: "module=exploit/windows/smb/ms17_010_psexec rhosts=$target_host lport=4444"
        Returns:
            dict: name value pair of the parameters
            For example: { 'module': 'exploit/windows/smb/ms17_010_psexec', 'rhosts': '$target_host',
                'lport': '4444' }
        '''
        parameters = {}

        action_value_list = action_value.split(' ')

        for action_value in action_value_list:
            if '=' in action_value:
                name, value = action_value.split('=')
                parameters[name] = value

        return parameters

    def resolve_capability_action(self, capability, values=None, resolvedActions=None):
        ''' Populate parameters in capability actions and passes from child to parent capabilities
        Arguments:
            capability(Capability): The capability to resolve parameters for
            values(dict): A dictionary of parameter names and values
            resolvedActions(list): A list of actions with parameters populated
        Returns:
            resolvedActions(list): This list of actions with parameters populated
        '''

        if values is None:
            values = {}

        if resolvedActions is None:
            resolvedActions = []
        logger.debug("Resolving actions for capability: {}:{} (Values = {})".format(capability.capabilitySubClass, capability.capabilityCVEs, values))

        for action in capability.actions:
            resolved_action = copy.deepcopy(action)
            if resolved_action['type'] == 'capability':
                parameters = Planner.get_parameter_dict(resolved_action['value'])

                for pName, pValue in parameters.items():
                    values[pName] = pValue
                if capability.capabilityClass == 'service':
                    for lCapability in self.capabilities.keys():
                        if self.capabilities[lCapability].capabilitySubClass == capability.preconditions[0]['value']:
                            parentCapability = self.capabilities[lCapability]
                            break
                    try:
                        self.resolve_capability_action(parentCapability, values, resolvedActions)
                    except:
                        pass
            else:
                parameters = Planner.get_parameter_dict(resolved_action['value'])

                for pName, pValue in parameters.items():
                    if pValue.startswith('$') and pName in values.keys():
                        resolved_action['value'] = resolved_action['value'].replace(pValue, values[pName])
                resolvedActions.append(resolved_action)

        return resolvedActions

    def update_status(self, status):
        if self.is_derived(status):
            for status_part in status.split('.'):
                self.state.add_status(status_part)
        else:
            self.state.add_status(status)

    def set_post_conditions(self, targetHost, capabilityID):
        ''' Sets the post conditions for the supplied capability for the target host in state
        Arguments:
            targetHost(str): The host for which the capability is being used
            capability(Capability): A list of actions with parameters populated
        Modifies: state(State): Updated per capability postconditions
        Returns: None
        '''

        logger.debug("Setting post-conditions for capability: {}".format(capabilityID))

        postconditions = self.capabilities[capabilityID].postconditions

        self.update_status(capabilityID)

        for condition in postconditions:
            conditionType = condition['type']
            conditionKey = condition['key']
            conditionValue = condition['value']
            logger.debug("Setting post-condition Type: {}, Key: {}, Value: {}".format(conditionType, conditionKey, conditionValue))
            # Currently the only postconditions are updating state
            if conditionType == 'state':
                if conditionKey == 'current_status':
                    self.state.add_status(conditionValue)
                elif conditionKey == 'current_access':
                    self.state.current_access = AccessClass[conditionValue]
                elif conditionKey == 'current_role':
                    if conditionValue == '$role':
                        role = self.state.temp['role']
                        self.state.current_role = UserRole[role]
                    else:
                        self.state.current_role = UserRole[conditionValue]
                elif conditionKey == 'current_host':
                    if conditionValue == '$target_host':
                        self.state.current_host = targetHost
                    else:
                        self.state.current_host = conditionValue
                elif conditionKey == 'add_credential_pwd':
                    username, password = conditionValue.split(',')
                    self.self.state.add_credential(targetHost, conditionKey, username, password)
                elif conditionKey == 'add_credential_hash':
                    self.state.add_credential(targetHost, conditionKey, credentialHash=conditionValue)

        # If the capability is derived, recurse and set post conditions for parent capabilities
        if self.is_derived(capabilityID):
            self.set_post_conditions(targetHost, self.get_parent_capabilityID(capabilityID))

    def get_sensitive_states(self):
        ''' Load sensitive state information from configuration file
        Arguments: None
        Modifies: self.sensitives(dict): A global dictionary of state name, type, key and value
        Returns: None
        '''
        for sensitive_item in config.options('SENSITIVE'):
            logger.debug('sensitive_item: {}'.format(sensitive_item))
            newSensitive = ast.literal_eval(config.get('SENSITIVE', sensitive_item))
            self.sensitives.append(newSensitive)

    def set_goals(self):
        ''' Load goal state information from configuration file
        Arguments: None
        Modifies: self.goals(dict): A global dictionary of goal name, type, key and value
        Returns: None
        '''
        logger.debug("Setting Goal States")
        for goal_item in config.options('GOALS'):
            newGoal = ast.literal_eval(config.get('GOALS', goal_item))
            newGoal['id'] = goal_item
            self.goals.append(newGoal)

    def run(self):
        if not 'INITIAL CONDITIONS' in config.sections():
            logger.error('INITIAL CONDITIONS not set: could not run planner.  Please update configuration file to enable.')
            logger.error('See example settings in the configuration file: {}'.format(get_config_filename()))
            sys.exit()

        if not 'GOALS' in config.sections():
            logger.error('GOALS not set: could not run planner.  Please update configuration file to enable.')
            logger.error('See example settings in the configuration file: {}'.format(get_config_filename()))
            sys.exit()

        # Set initial state from configuration file
        self.set_initial_state()

        # Set the GOAL (end condition) from the configuration file
        self.set_goals()

        logger.info("Calculating Attack Paths")
        self.find_all_paths()
