#!/usr/bin/env python3
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Perspecta Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


#from mock import patch
from io import StringIO
import unittest
from unittest import mock

from a2p2v.analyzer import Analyzer
from a2p2v.analyzer import Capability

import a2p2v.database

# Capability: possible classes and subclasses
possible_classes = ['exploit', 'service']
possible_subclasses = ['remote_code_execution', 'local_code_execution', 'privilege_escalation']

class TestAnalyzer(unittest.TestCase):
    @mock.patch.object(Analyzer, 'get_capabilities_from_database')
    @mock.patch.object(Analyzer, 'connect_to_database')
    def test_constructor(self, mock_connect_to_database, mock_get_capabilities_from_database):
        '''Test the constructor by patching the database routines'''
        analyzer = Analyzer(execute=None, plan=None, datafile=None, netfile=None)
        mock_connect_to_database.assert_called()
        mock_get_capabilities_from_database.assert_called()
    
    def test_capability(self):
        for capability_class in possible_classes:
            for capability_subclass in possible_subclasses:
                capability = Capability(capID=1, capTitle='test1', cclass=capability_class, csubclass=capability_subclass, \
                    severity='1', cvelist=[], cvss='', preconditions=[], actions=[], postconditions=[], rank='', solution='')
    
    # NOTE: the module that gets patches ends up falling underneath
    # the module being tested.  e.g. instead of patching "os.path" it is "a2p2v.analyzer.os.path"
    @mock.patch.object(Analyzer, 'get_capabilities_from_database')
    @mock.patch('a2p2v.analyzer.sqlite3')
    @mock.patch('a2p2v.analyzer.os')
    def test_connect_to_database(self, mock_os, mock_sqlite3, mock_get_capabilities_from_database):
        analyzer = Analyzer(execute=None, plan=None, datafile=None, netfile=None)
        database_file = a2p2v.database.get_database_filename()
        mock_os.path.isfile.assert_called_with(database_file)
        mock_sqlite3.connect.assert_called_with(database_file)
        mock_get_capabilities_from_database.assert_called()
        
    @mock.patch.object(Analyzer, 'get_capabilities_from_database')
    @mock.patch.object(Analyzer, 'connect_to_database')
    def test_database_execute_query(self, mock_connect_to_database, mock_get_capabilities_from_database):
        analyzer = Analyzer(execute=None, plan=None, datafile=None, netfile=None)
        analyzer.dbconn = mock.Mock()
    
        rows = analyzer.database_execute_query('', commit=False)
        self.assertIsNotNone(rows)
    
        rows = analyzer.database_execute_query('', commit=True)
        self.assertIsNone(rows)
    
    @mock.patch.object(Analyzer, 'get_capabilities_from_database')
    @mock.patch.object(Analyzer, 'connect_to_database')
    def get_analyzer(self, mock_connect_to_database, mock_get_capabilities_from_database):
        # Create an analyzer and populate it with some data
        analyzer = Analyzer(execute=None, plan=None, datafile=None, netfile=None)
        analyzer.hostsDB = {
                'GW': {'interfaces': {('192.168.30.1', ''), ('172.16.1.1', '')}, 'capabilities': []},
                'USER1': {'interfaces': {('192.168.30.102', '')}, 'capabilities': []}, 
                'HMI': {'interfaces': {('192.168.20.101', ''), ('192.168.30.101', '')}, 'capabilities': []}, 
                'ATTACKER': {'interfaces': {('192.168.30.200', '')}, 'capabilities': []},
                'USER2': {'interfaces': {('192.168.20.103', ''), ('192.168.10.103', '')},'capabilities': []},
                'OPC': {'interfaces': {('192.168.20.104', ''), ('192.168.10.104', '')}, 'capabilities': []},
                'PLC': {'interfaces': {('192.168.10.71', '')}, 'capabilities': []}
        }
        return analyzer
    
    def test_ip_to_hostname(self):
        analyzer = self.get_analyzer()
    
        # Verify that ip_to_hostname() returns the expected results
        self.assertEqual(analyzer.ip_to_hostname('172.16.1.1'), 'GW')
        self.assertEqual(analyzer.ip_to_hostname('192.168.30.1'), 'GW')
        self.assertEqual(analyzer.ip_to_hostname('192.168.30.102'), 'USER1')
        self.assertEqual(analyzer.ip_to_hostname('192.168.20.101'), 'HMI')
        self.assertEqual(analyzer.ip_to_hostname('192.168.30.101'), 'HMI')
        self.assertEqual(analyzer.ip_to_hostname('192.168.30.200'), 'ATTACKER')
        self.assertEqual(analyzer.ip_to_hostname('192.168.20.103'), 'USER2')
        self.assertEqual(analyzer.ip_to_hostname('192.168.10.103'), 'USER2')
        self.assertEqual(analyzer.ip_to_hostname('192.168.20.104'), 'OPC')
        self.assertEqual(analyzer.ip_to_hostname('192.168.10.104'), 'OPC')
        self.assertEqual(analyzer.ip_to_hostname('192.168.10.71'), 'PLC')
        self.assertEqual(analyzer.ip_to_hostname('unknown'), 'UNKNOWN')
    
    def test_get_config_options(self):
        # TODO:
        pass
    
    def test_add_capabilities_to_host(self):
        # Create a testing analyzer 
        analyzer = self.get_analyzer()
    
        # Create some testing capabilities
        capability1 = Capability(capID='test1', capTitle='test case 1', cclass='exploit', csubclass='remote_code_execution',
            severity='4', cvelist=[], cvss='', preconditions=None, actions=None, postconditions=None, rank=None, solution=None)
        capability2 = Capability(capID='test2', capTitle='test case 2', cclass='exploit', csubclass='remote_code_execution',
            severity='4', cvelist=[], cvss='', preconditions=None, actions=None, postconditions=None, rank=None, solution=None)
    
        capabilities = [capability1, capability2]

        for capability in capabilities:
            analyzer.capabilities[capability.capabilityID] = capability
    
        # Add the capabilities to the host
        analyzer.add_capabilities_to_host('192.168.20.101', capabilities)
    
        # Verify that the capabilities were added
        capability_ids = [capability.capabilityID for capability in analyzer.hostsDB['HMI']['capabilities']]
    
        #self.assertIn('test1', capability_ids)
        #self.assertIn('test2', capability_ids)
    
        # Add another capability to the host, by using a different IP address
        capability3 = Capability(capID='test3', capTitle='test case 3', cclass='exploit', csubclass='remote_code_execution',
            severity='4', cvelist=[], cvss='', preconditions=None, actions=None, postconditions=None, rank=None, solution=None)
    
        analyzer.add_capabilities_to_host('192.168.30.101', [capability3])
    
        # Verify that the capabilities were added
        capability_ids = [capability.capabilityID for capability in analyzer.hostsDB['HMI']['capabilities']]
    
        #self.assertIn('test1', capability_ids)
        #self.assertIn('test2', capability_ids)
        #self.assertIn('test3', capability_ids)
    
        print(analyzer.capabilities)
    
    def test_run(self):
        # TODO
        pass
    
    @mock.patch.object(Analyzer, 'connect_to_database')
    @mock.patch.object(Analyzer, 'get_capabilities_from_database')
    @mock.patch('a2p2v.analyzer.open')
    def test_detect_plugin_type(self, mock_open, mock_connect_to_database, mock_get_capabilities_from_database):
        '''Test the constructor by patching the database routines'''
        analyzer = Analyzer(execute=None, plan=None, datafile='', netfile=None)
        analyzer._detect_plugin_type()
        mock_open.assert_called()
        self.assertEqual(analyzer.scan_plugin, 'unknown')
    
        # TODO: How to make mock_open return
    
    def test_parse_network_xml(self):
        # TODO
        pass
    
    def test_parse_common_csv(self):
        # TODO
        pass
    
    def test_get_capabilities_from_database(self):
        # TODO
        pass
    
    def test_get_capability_by_id(self):
        # TODO
        pass
    
    def test_add_capability(self):
        # TODO
        pass
    
    def test_get_service_capability_by_port(self):
        # TODO
        pass
    
    def test_parse_nmap_xml(self): 
        # TODO
        pass
    
    def test_classify_vulnerability(self):
        analyzer = self.get_analyzer()
    
    def test_add_metasploit_capability(self):
        # TODO
        pass
    
    def test_parse_nessus_xml(self): 
        # TODO
        pass
    
    def test_report_capabilities(self):
        # TODO
        pass
    
    def test_fix_metasploit_options(self):
        # TODO
        pass
    
    '''
    def test_temp_func(self):
        with patch('a2p2v.analyzer.MetasploitDB') as magic:
            analyzer = self.get_analyzer()
            info = analyzer.temp_func('exploit/windows/smb/ms17_010_psexec')
    
            #assert(info.rank == 'normal')
            #assert(info.module_type == 'exploit')
    
    '''
